[
  {
    "objectID": "RGV410046_08_DATAVIZ.html",
    "href": "RGV410046_08_DATAVIZ.html",
    "title": "8. Visualização de dados",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#grãos-café",
    "href": "RGV410046_08_DATAVIZ.html#grãos-café",
    "title": "8. Visualização de dados",
    "section": "\n3.1 Grãos café",
    "text": "3.1 Grãos café\nOs dados contidos na aba cafe do arquivo examples_data.xlsx serão utilizados. Este arquivo contém dados do comprimento e largura (mm) de grãos de café, amostrados por diferentes grupos de alunos da disciplina de Bioestatística e Experimentação Agrícola e classificados em diferentes cores. Para carregar estes dados, utilizamos o seguinte comando.\n\ndf &lt;- \n  import(\"examples_data.xlsx\",\n         sheet = \"cafe\",\n         setclass = \"tbl\") |&gt; \n  as_factor(1:3)\ndf\n\n# A tibble: 47 × 5\n   grupo   individuo cor      comprimento largura\n   &lt;fct&gt;   &lt;fct&gt;     &lt;fct&gt;          &lt;dbl&gt;   &lt;dbl&gt;\n 1 Grupo 1 1         vermelho       13.5     16.6\n 2 Grupo 1 2         vermelho       11.1     14.2\n 3 Grupo 1 3         vermelho       13.4     15.9\n 4 Grupo 1 4         vermelho        9.87    14.1\n 5 Grupo 1 5         verde          11.6     16.1\n 6 Grupo 1 6         verde           9.86    13.9\n 7 Grupo 1 7         verde           9.84    12.4\n 8 Grupo 1 8         verde          10.7     14.8\n 9 Grupo 1 9         verde           9.98    13.2\n10 Grupo 1 10        verde          10.3     13  \n# ℹ 37 more rows"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#dados-da-estação-meteorológica",
    "href": "RGV410046_08_DATAVIZ.html#dados-da-estação-meteorológica",
    "title": "8. Visualização de dados",
    "section": "\n3.2 Dados da estação meteorológica",
    "text": "3.2 Dados da estação meteorológica\nOs dados contidos em estacao_fazenda.csv contém informações de variáveis climáticas obtidas em sensores automáticos de uma estação meteorológica localizada na Fazenda Experimental da Ressacada (UFSC)\n\n\n\n\n\n\nOs dados são em escala horária, do dia 01/01/2022 a 28/11/2022, totalizando 7957 observações. Estes dados serão utilizados ainda neste material, na sessão Section 4.12.\n\ndf_estacao &lt;-  \n  import(\"estacao_fazenda.csv\", setclass = \"tbl\") |&gt;\n  mutate(dia = dmy(dia),\n         m = fct_relevel(factor(m), paste0(1:12))) # reordena os meses\ndf_estacao\n\n# A tibble: 8,759 × 12\n   dia        m      prec  tmax  tmed  tmin urmax urmed urmin dirvent velvent\n   &lt;date&gt;     &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 2022-01-01 1         0  21.2  20.6  20.2   100  99.5  99.0     0     0    \n 2 2022-01-01 1         0  20.5  19.8  19.4   100  99.9  99.6     0     0    \n 3 2022-01-01 1         0  19.7  19.4  19.0   100 100.   99.9     0     0    \n 4 2022-01-01 1         0  20.0  19.2  18.7   100 100   100       0     0    \n 5 2022-01-01 1         0  20.5  20.2  19.8   100 100   100       0     0    \n 6 2022-01-01 1         0  20.7  20.2  19.9   100 100   100      79.8   0.331\n 7 2022-01-01 1         0  20.2  19.7  19.1   100 100   100       0     0    \n 8 2022-01-01 1         0  20.0  19.5  19.1   100 100   100       0     0    \n 9 2022-01-01 1         0  22.1  21.2   0     100  99.3   0       0     0    \n10 2022-01-01 1         0  26.0  24.3  22.1   100  89.0  78.6   287.    0.087\n# ℹ 8,749 more rows\n# ℹ 1 more variable: rajada &lt;dbl&gt;"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#o-pacote-ggplot2",
    "href": "RGV410046_08_DATAVIZ.html#o-pacote-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n4.1 O pacote ggplot2\n",
    "text": "4.1 O pacote ggplot2\n\nO ggplot2 é um pacote R para produção de gráficos que diferentemente da maioria dos outros pacotes, apresenta uma profunda gramática baseada no livro The grammar of graphics (Wilkinson 2005)1. Os gráficos originados em ggplot2 são baseados em camadas, e cada gráfico tem três componentes chave: data, os dados de onde o gráfico será criado; aes() (aesthetic mappings), que controla o mapeamento estético e as propriedades visuais do gráfico; e ao menos uma camada que irá descrever como cada observação será renderizada. Camadas são usualmente criadas utilizando uma função geom_()."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#galerias",
    "href": "RGV410046_08_DATAVIZ.html#galerias",
    "title": "8. Visualização de dados",
    "section": "\n4.2 Galerias",
    "text": "4.2 Galerias\n\nhttps://www.r-graph-gallery.com/portfolio/ggplot2-package/\nhttp://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html\nhttps://r4stats.com/examples/graphics-ggplot2/\nhttp://girke.bioinformatics.ucr.edu/GEN242/pages/mydoc/Rgraphics.html"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#extensões-do-ggplot2",
    "href": "RGV410046_08_DATAVIZ.html#extensões-do-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n4.3 Extensões do ggplot2\n",
    "text": "4.3 Extensões do ggplot2\n\n\nhttp://www.ggplot2-exts.org/gallery/\nhttps://mode.com/blog/r-ggplot-extension-packages"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#tutoriais-em-português",
    "href": "RGV410046_08_DATAVIZ.html#tutoriais-em-português",
    "title": "8. Visualização de dados",
    "section": "\n4.4 Tutoriais em português",
    "text": "4.4 Tutoriais em português\n\nhttps://rpubs.com/mnunes/ggplot2\nhttps://analisereal.com/2015/09/19/introducao-ao-ggplot2/\nhttps://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only/\nhttp://recologia.com.br/tag/graficos/\nhttp://rstudio-pubs-static.s3.amazonaws.com/24563_3b7b0a6414824e3b91769a95309380f1.html\nhttp://eduardogutierres.com/inteligencia-geografica-gerando-mapas-em-r/\nhttps://pt.stackoverflow.com/questions/332053/r-mapa-de-cidades-brasileiras"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#meu-primeiro-gráfico-em-ggplot2",
    "href": "RGV410046_08_DATAVIZ.html#meu-primeiro-gráfico-em-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n4.5 Meu primeiro gráfico em ggplot2\n",
    "text": "4.5 Meu primeiro gráfico em ggplot2\n\nA seguir, vamos discutir os aspcetos básicos para a construção de gráficos utilizando o pacote ggplot2. A função arrange_ggplot() do pacote metan é utilizada aqui para organizar os gráficos em forma de painéis."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#as-camadas-de-um-gráfico-ggplot2",
    "href": "RGV410046_08_DATAVIZ.html#as-camadas-de-um-gráfico-ggplot2",
    "title": "8. Visualização de dados",
    "section": "\n4.6 As camadas de um gráfico ggplot2\n",
    "text": "4.6 As camadas de um gráfico ggplot2\n\nNo ggplot2, os gráficos são construídos camada por camada (ou, layers, em inglês). Neste exemplo, vamos confeccionar um gráfico mostrando a distribuição do comprimento da folha (eixo x) e largura da folha (eixo y).\n\np1 &lt;- \n  ggplot(df, aes(x = comprimento, y = largura)) +\n  geom_point()\np1\n\n\n\n\nEste comando criou um gráfico e armazenou no objeto p1, que será plotado posteriormente. Observe que o primeiro argumento da função é o data frame onde nossos dados foram armazenados. A função aes() descreve como as variáveis são mapeadas (neste caso comprimento no eixo x e largura no eixo y). A função geom_point() definiu que a forma geométrica a ser utilizada é baseada em pontos, gerando, assim, um gráfico de dispersão. Isto é tudo que precisa ser feito para a confecção de um gráfico simples."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#aesthetics-estética",
    "href": "RGV410046_08_DATAVIZ.html#aesthetics-estética",
    "title": "8. Visualização de dados",
    "section": "\n4.7 Aesthetics (estética)",
    "text": "4.7 Aesthetics (estética)\n\n“O maior valor de uma imagem é quando ela nos obriga a perceber o que nunca esperamos ver.” — John Tukey\n\nAlterar a estética dos gráficos ggplot2 é uma tarefa relativamente simples. No gráfico anterior, os valores do comprimento e largura foram plotados sem nenhum tipo de mapeamento estético. Digamos que marcadores com diferentes cores para cada nível do fator cor poderia nos ajudar a compreender melhor o padrão presente em nossos dados. Vamos confeccionar este gráfico.\n\np2 &lt;- \n  ggplot(df, aes(x = comprimento,\n                 y = largura,\n                 colour = cor)) +\n  geom_point()\np2\n\n\n\n\nAo incluirmos colour = cor dentro da função aes, dizemos ao ggplot que os pontos devem ser mapeados esteticamente (neste caso utilizando cores) para cada nível do fator cor presente em nossos dados. Digamos que em vez de utilizar diferentes cores, a cor do grão do café deveria ser representada por diferentes tipos de marcadores (quadrados, triângulo, etc.) Neste caso, o argumento colour = cor é substituído por shape = cor.\n\np3 &lt;- \n  ggplot(df, aes(x = comprimento, \n                 y = largura,\n                 shape = cor,\n                 color = cor)) +\n  geom_point()\n\n\n# organizar os gráficos\narrange_ggplot(p1, p2, p3,\n               ncol = 3,\n               tag_levels = list(c(\"p1\", \"p2\", \"p3\")))"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#salvar-gráficos",
    "href": "RGV410046_08_DATAVIZ.html#salvar-gráficos",
    "title": "8. Visualização de dados",
    "section": "\n4.8 Salvar gráficos",
    "text": "4.8 Salvar gráficos\nA função ggsave() é uma função conveniente para salvar um gráfico. O padrão é salvar a última plotagem exibida, usando o tamanho do dispositivo gráfico atual. Também é possível informar a altura (height) e largura (width). Ele também adivinha o tipo de dispositivo gráfico da extensão. No seguinte exemplo, o gráfico acima é salvo no diretório de trabalho atual com o nome pontos.png, com 5 polegadas de altura e 10 de largura.\n\nggsave(\"pontos.png\",\n       height = 5,\n       width = 10)"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#facet-facetas",
    "href": "RGV410046_08_DATAVIZ.html#facet-facetas",
    "title": "8. Visualização de dados",
    "section": "\n4.9 Facet (facetas)",
    "text": "4.9 Facet (facetas)\nMapeando os diferentes níveis de cor para diferentes cores, incluímos em um único gráfico os dados de todos osgrupos. Mas, e se nosso objetivo fosse realizar um gráfico para cada grupo? O ggplot2 tem uma poderosa ferramenta para isto: as funções facet_. Ao utilizar estas funções, o conjunto de dados é subdividido e um gráfico é construído para cada um destes subconjuntos. Vamos ver como elas podem nos ajudar em nosso problema.\n\nfac1 &lt;- \n  ggplot(df, aes(x = comprimento,\n                 y = largura,\n                 color = cor)) +\n  geom_point() +\n  facet_wrap(~ grupo)\nfac1\n\n\n\nUm painel para cada nível da variável grupo.\n\n\n\nNeste exemplo, um gráfico completamente diferente do anterior é gerado com apenas uma simples adição: incluímos uma nova função, facet_wrap(~ grupo). Neste caso, informamos que um gráfico deveria ser realizado para cada grupo."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#theme-temas",
    "href": "RGV410046_08_DATAVIZ.html#theme-temas",
    "title": "8. Visualização de dados",
    "section": "\n4.10 Theme (temas)",
    "text": "4.10 Theme (temas)\nCada gráfico criado com a função ggplot() tem um tema padrão. Tema, aqui, é toda propriedade relacionada ao aspecto visual do gráfico, que não foi definida na função aes() e que pode ser modificada utilizando a função theme() (veja ?theme). O ggplot2 já conta com alguns temas personalizados para facilitar nosso trabalho. Considerando o exemplo anterior, vamos utilizar a função theme_bw() (preto e branco) e a função theme() para modificar as propriedades visuais do gráfico.\n\nfac2 &lt;- \n  ggplot(df, aes(x = comprimento, y = largura, color = cor)) +\n  geom_point() +\n  facet_wrap(~ grupo) +\n  theme_light() +\n  theme(panel.grid.minor = element_blank(), # remove as linhas do corpo do gráfico\n        # sem bordas entre os painéis\n        panel.spacing = unit(0, \"cm\"),\n        # legenda abaixo do gráfico\n        legend.position = \"bottom\",\n        # modifica o texto dos eixos\n        axis.text = element_text(size = 12, colour = \"black\"),\n        # cor dos marcadores\n        axis.ticks = element_line(colour = \"black\"),\n        # tamanho dos marcadores\n        axis.ticks.length = unit(.2, \"cm\"), \n        #cor da borda\n        panel.border = element_rect(colour = \"black\", fill = NA, size = 0.5))+\n  # título dos eixos\n  labs(x = \"Comprimento do grão (mm)\", # título do eixo x\n       y = \"Largura do grão (mm)\", # título do eixo y\n       color = \"\") # título da legenda\n\narrange_ggplot(fac1, fac2,\n               ncol = 1,\n               tag_levels = list(c(\"f1\", \"f2\")))\n\n\n\nGráfico de dispersão considerando a confecção de um gráfico para cada nível de um fator(f1) e modificações na propriedades do tema de um gráfico ggplot2 (f2)\n\n\n\nOs argumentos inseridos dentro das função theme() modificaram a aparência do nosso gráfico. Inúmeros outros argumentos são disponíveis, fazendo com que os gráficos originados sejam completamente personalizáveis. Digamos que precisamos confeccionar diversos gráficos e gostaríamos de manter o mesmo tema do gráfico acima. Seria exaustivo e desinteressante informar cada vez estes argumentos para cada gráfico, não? Felizmente, outra poderosa ferramenta proporcionada pelo ggplot2 é a possibilidade de confeccionarmos nossos próprios temas. Para isto, vamos executar o seguinte comando para criar um tema personalizado (my_theme()). Este tema pode então ser aplicado como uma camada adicional a cada gráfico que confecionarmos. Para evitar a necessidade da inclusão deste tema em cada gráfico gerado, iremos definir este tema como padrão utilizando a função theme_set().\n\nmy_theme &lt;- function () {\n  theme_light() %+replace% # permite que os valores informados possam ser sobescritos\n    theme(axis.ticks.length = unit(.2, \"cm\"),\n          axis.text = element_text(size = 12, colour = \"black\"),\n          axis.title = element_text(size = 12, colour = \"black\"),\n          axis.ticks = element_line(colour = \"black\"),\n          panel.border = element_rect(colour = \"black\", fill = NA, size = 0.5),\n          panel.grid.minor =  element_blank())\n}\ntheme_set(my_theme())"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#geoms-geometria",
    "href": "RGV410046_08_DATAVIZ.html#geoms-geometria",
    "title": "8. Visualização de dados",
    "section": "\n4.11 Geoms (geometria)",
    "text": "4.11 Geoms (geometria)\nAs funções geom_ definem qual forma geométrica será utilizada para a visualização dos dados no gráfico. Até agora, utilizamos a função geom_point()para construir gráficos de dispersão. Basicamente, qualquer outro tipo de gráfico pode ser criado dependendo da função geom_ utilizada. Dentre as diversas disponíveis no pacote ggplot2 as funções geom_ mais utilizadas são:\n\n\ngeom_abline(): para retas definidas por um intercepto e uma inclinação;\n\ngeom_hline(): para retas horizontais definidas por um intercept y;\n\ngeom_vline(): para retas verticais definidas por um intercept x;\n\ngeom_boxplot(): para boxplots;\n\ngeom_histogram(): para histogramas de frequência;\n\ngeom_smooth(): ajusta uma função para o conjunto de dados e mostra uma banda de confiança;\n\ngeom_density(): para densidades;\n\ngeom_area(): para áreas;\n\ngeom_bar(): para barras;\n\ngeom_errorbar() para barras de erro;\n\nDeste ponto em diante, vamos confeccionar alguns exemplos utilizando algumas destas funções (ou combinações destas funções) incluindo argumentos de mapeamento de estética e temas vistos até agora.\n\n4.11.1 Linhas horizontais, verticais e diagonais\nTrês importantes geometrias são apresentadas a seguir:\n\ngeom_hline() adiciona uma linha horizontal definida por um intercepto em y\ngeom_vline() adiciona uma linha vertical definida por um intercepto em x.\ngeom_abline() adiciona uma linha diagonal definida por um intercepto e uma inclinação.\n\n\ng1 &lt;- \n  ggplot(df, aes(comprimento, largura)) +\n  geom_point()\ng1\n\n\n\n# adiciona linhas horizontais e verticais\ng2 &lt;- \n  g1 +\n  geom_hline(yintercept = mean(df$largura), color = \"blue\") +\n  geom_vline(xintercept = mean(df$comprimento), color = \"red\")\n\narrange_ggplot(g1, g2,\n               ncol = 1,\n               tag_levels = list(c(\"g1\", \"g2\")))\n\n\n\n\n\n4.11.2 Gráficos do tipo boxplot\n\nbox1 &lt;- \n  ggplot(df, aes(grupo, comprimento)) +\n  geom_boxplot()\n\nbox2 &lt;- \n  ggplot(df, aes(grupo, comprimento)) +\n  geom_boxplot(outlier.colour = \"transparent\") +\n  geom_jitter(width = 0.1, color = \"salmon\")\n\nbox3 &lt;- \n  ggplot(df, aes(grupo, comprimento, fill = cor)) +\n  geom_boxplot(width = 0.3) + \n  labs(x = \"Grupo\",\n       y = \"Comprimento do grão (mm)\") +\n  theme(legend.position = \"bottom\") +\n  scale_fill_manual(values = c(\"green\", \"red\"))\n\narrange_ggplot((box1 + box2) / box3,\n               tag_levels = list(c(\"b1\", \"b2\", \"b3\")))\n\n\n\nGráfico do tipo boxplot combinando mapeamentos estéticos.\n\n\n\nCinco estatísticas são mostradas neste boxplot. A mediana (linha horizontal), as caixas inferior e superior (primeiro e terceiro quartil (percentis 25 e 75, respectivamente)). A linha vertical superior se estende da caixa até o maior valor, não maior que $1,5 $ (onde IQR é a amplitude interquartílica). A linha vertical inferior se estende da caixa até o menor valor, de no máximo, $1,5 $. Dados além das linhas horizontais podem ser considerados outliers.\n\n4.11.3 Gráficos do tipo barra\nNo seguinte exemplo, os dados do comprimento do grão de café disponíveis em df são utilizados.\n\nbar1 &lt;- \n  ggplot(df, aes(x = grupo, y = comprimento)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\nbar2 &lt;- \n  ggplot(df, aes(x = grupo, y = comprimento, fill = cor)) +\n  stat_summary(fun = mean,\n               geom = \"bar\",\n               col = \"black\",\n               width = 0.8,\n               position = position_dodge(0.8)) + \n  stat_summary(fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.2,\n               position = position_dodge(0.8))\n\n\narrange_ggplot(bar1, bar2,\n               widths = c(0.6, 1.2),\n               tag_levels = list(c(\"bar1\", \"bar2\")))\n\n\n\nGráfico do tipo barras, com mapeamento estético e barras de erro.\n\n\n\nA afirmação de que um gráfico ggplot2 é feito em camadas fica mais evidente aqui. No gráfico bar1, as barras representam as médias geral do comprimento para cada grupo. No segundo gráfico, ao usar fill = cor informamos que as barras devem ser coloridas para cada nível do fator cor. A função stat_summary(), é vista pela primeira vez aqui, foi utilizada no segundo gráfico para substituir a função geom_bar(). Com isto, foi possível incluir as médias (fun = mean e geom = \"bar), bem como as barras de erro (fun.data = mean_se e geom = \"errorbar\").\nUtilizando a função plot_factbars() do pacote metan, um gráfico semelhante pode ser criado com as funções plot_bars() e plot_factbars()\n\nmetan1 &lt;- \n  plot_bars(df,\n            x = grupo,\n            y = comprimento)\nmetan2 &lt;- \n  plot_factbars(df, # dados\n                grupo, cor, # dois fatores\n                resp = comprimento) # eixo y\n\narrange_ggplot(metan1, metan2,\n               widths = c(0.6, 1.2),\n               tag_levels = list(c(\"metan1\", \"metan2\")))\n\n\n\n\n\n4.11.4 \n\n4.11.5 Gráficos do tipo histograma\nNeste exemplo, utilizaremos os dados de temperatura média da estação meteorológica, disponível no data frame df_estacao. O primeiro histograma (p1) mostra os dados gerais desde 01/01/2022. No segundo, um histograma é gerado para cada mês.\n\nh1 &lt;- \n  ggplot(df_estacao, aes(x = tmed)) +\n  geom_histogram()\n\nh2 &lt;- \n  ggplot(df_estacao, aes(x = tmed)) +\n  geom_histogram(fill = \"green\") +\n  facet_wrap(~m) +\n  labs(x = \"Temperatura média (ºC)\",\n       y = \"Número de horas\")\n\narrange_ggplot(h1, h2,\n               widths = c(1, 1.4),\n               tag_levels = list(c(\"h1\", \"h2\")))\n\n\n\nGráfico do tipo histograma\n\n\n\n\n4.11.6 Gráficos de densidade\nOs gráficos de densidade, têm a mesma interpretação que histogramas, no então são esteticamente mais atraente. Os primeiros dois exemplos nada mais são que a versão densidade dos histogramas apresentados anteriormente.\nNo terceiro exemplo (d3), é mostrado como é possível construir um gráfico de densidade ridges. Gráficos ridges são gráficos de linha parcialmente sobrepostos que criam a impressão de uma cordilheira. Eles podem ser bastante úteis para visualizar mudanças nas distribuições ao longo do tempo ou espaço2.\n\nd1 &lt;- \n  ggplot(df_estacao, aes(x = tmed)) +\n  geom_density()\n\nd2 &lt;- \n  ggplot(df_estacao, aes(x = tmed)) +\n  geom_density(color = \"black\",\n               fill = \"skyblue\") +\n  facet_wrap(~m, ncol = 6) +\n  labs(x = \"Temperatura média (ºC)\",\n       y = \"Densidade\")\n\nd3 &lt;- \n  ggplot(df_estacao, aes(x = tmed, y = m, fill = stat(x))) +\n  geom_density_ridges_gradient() +\n  scale_fill_viridis_c() +\n  labs(x = \"Temperatura média (ºC)\",\n       y = \"Meses do ano\",\n       fill = \"Temperatura\\nmédia (ºC)\")\n\n# agrupa os gráficos\narrange_ggplot(d1 + d2,\n               d3,\n               nrow = 2,\n               heights = c(0.3, 0.7), # maior altura do gráfico d3\n               tag_levels = list(c(\"d1\", \"d2\", \"d3\")))\n\n\n\nGráfico do tipo densidade\n\n\n\n\n4.11.7 Gráficos de linhas\nO seguinte exemplo mostra a temperatura mínima, média e máxima ao longo dos dias desde 01/01/2022. Primeiro, é preciso obter as temperaturas mínimas, máximas e médias de cada dia. Fazemos isso com a função summarise().\n\nclima_max_min &lt;-\n  df_estacao %&gt;%\n  group_by(dia) %&gt;% \n  summarise(max = max(tmax),\n            min = min(tmin),\n            mean = mean(tmed),\n            precip = sum(prec)) %&gt;% \n  pivot_longer(-dia)\nclima_max_min\n\n# A tibble: 1,460 × 3\n   dia        name   value\n   &lt;date&gt;     &lt;chr&gt;  &lt;dbl&gt;\n 1 2022-01-01 max     28.7\n 2 2022-01-01 min      0  \n 3 2022-01-01 mean    24.0\n 4 2022-01-01 precip   0  \n 5 2022-01-02 max     31.8\n 6 2022-01-02 min     23.4\n 7 2022-01-02 mean    27.1\n 8 2022-01-02 precip   0  \n 9 2022-01-03 max     32.4\n10 2022-01-03 min     24.3\n# ℹ 1,450 more rows\n\n\n\n# realiza um subset para remover a precipitação\ndf_temp &lt;-  \n  clima_max_min |&gt;  \n  subset(name != \"precip\")\n\n# faz o gráfico de linhas\nggplot(df_temp, aes(dia, value, color = name, group = name)) +\n  geom_point() + \n  geom_line() + \n  scale_color_manual(values = c(\"red\", \"green\", \"blue\"),\n                     labels = c(\"Temperatura máxima (ºC)\",\n                                \"Temperatura média (ºC)\",\n                                \"Temperatura mínima (ºC)\"),\n                     guide = \"legend\") + \n  scale_x_date(date_breaks = \"3 week\", # marcação a cada duas semanas\n               date_labels = \"%d/%m/%y\") + # formato dd/mm/aa\n  theme(legend.position = \"bottom\",\n        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + \n  labs(title = \"Temperaturas máximas, médias e mínimas em 2022\",\n       subtitle = \"Estação - Fazenda Ressacada\",\n       caption = \"Elaboração: Prof. Olivoto\",\n       x = \"Dia do ano\",\n       y = \"Temperatura (ºC)\",\n       color = NULL) # remove o título da legenda\n\n\n\n\n\n4.11.8 \n\n4.11.9 Linha de regressão (linear)\n\nl1 &lt;-\n  ggplot(df, aes(x = comprimento, y = largura)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) + # estima uma regressão linear\n  labs(x = \"Comprimento do grão\",\n       y = \"Largura do grão\")\n\nl2 &lt;-\n  ggplot(df, aes(x = comprimento, y = largura, color = grupo)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = F)+\n  labs(x = \"Comprimento do grão\",\n       y = \"Largura do grão\")\n\narrange_ggplot(l1, l2,\n               tag_levels = list(c(\"s1\", \"s2\")),\n               widths = c(1, 1.2))\n\n\n\nGráfico de dispersão, combinando pontos e linhas de regressão.\n\n\n\n\n4.11.10 Linha de regressão (polinomial)\nPara confeccionar um gráfico de regressão polinomial, além do argumento method = \"lm\" (linear model), precisa-se incluir no argumento formula a formula utilizada, neste caso, definida utilizando poly() (polinomial).\n\n#### Polinômio de segundo grau\n\ndado_reg &lt;- tibble(dose = c(15,20,25,30,35,40),\n                   prod = c(65,70,73,75,69,62))\n\nq1 &lt;-\n    ggplot(dado_reg, aes(dose, prod))+\n    geom_point()+\n    stat_smooth(method = \"lm\",\n                formula = \"y ~ poly(x, 1)\",\n                se = FALSE)\n\nq2 &lt;-\n  q1 +\n  stat_smooth(method = \"lm\",\n              formula = \"y ~ poly(x, 2)\",\n              linetype = \"dashed\",\n              color = \"red\",\n              se = FALSE)\n\narrange_ggplot(q1, q2, tag_levels = list(c(\"l1\", \"l2\")))\n\n\n\nGráfico de dispersão combinado com inclusão de curvas ajustadas.\n\n\n\nUtilizando a função plot_lines() do pacote metan, um gráfico semelhante pode ser criado com\n\nplot_lines(dado_reg,\n           x = dose,\n           y = prod,\n           fit = 2)"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#sec-dados-da-estação",
    "href": "RGV410046_08_DATAVIZ.html#sec-dados-da-estação",
    "title": "8. Visualização de dados",
    "section": "\n4.12 Dados da estação",
    "text": "4.12 Dados da estação\n\n4.12.1 Exploração dos dados\n\nplot_intro(df_estacao)\n\n\n\n# Colunas numéricas\nplot_histogram(df_estacao, ncol = 5)\n\n\n\n\n\n4.12.2 Gráfico da precipitação e temperatura\n\n#| out-width: \"100%\"\n\ndf_prec &lt;- \n  clima_max_min |&gt; \n  pivot_wider(names_from = \"name\",\n              values_from = \"value\")\n\nggplot() +\n  geom_bar(df_prec,\n           mapping = aes(x = dia, y = precip * 30 / 100),\n           stat = \"identity\",\n           fill = \"skyblue\") +\n  geom_line(df_prec,\n            mapping = aes(x = dia, y = max, colour = \"red\"),\n            size = 1) +\n  geom_line(df_prec, \n            mapping = aes(x = dia, y = min, colour = \"blue\"),\n            size = 1) +\n  scale_x_date(date_breaks = \"15 days\", date_labels =  \"%d/%m\",\n               expand = expansion(c(0, 0)))+\n  scale_y_continuous(name = expression(\"Temperatura (\"~degree~\"C)\"),\n                     sec.axis = sec_axis(~ . * 100 / 30 , name = \"Precipitação (mm)\")) +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +\n  scale_color_identity(breaks = c(\"red\", \"blue\"),\n                       labels = c(\"Temperatura máxima (ºC)\",\n                                  \"Temperatura mínima (ºC)\"),\n                       guide = \"legend\") +\n  labs(x = \"Dia do ano\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\nTemperaturas máximas e mínimas e precipitação observada ao longo dos dias.\n\n\n\n\n4.12.3 Velocidade média do vento\n\nvento_long &lt;-\n  df_estacao %&gt;%\n  select(m, dia, velvent) %&gt;% \n  pivot_longer(-c(m, dia))\n\n\n\n# confeccionar gráfico\nggplot(vento_long, aes(m, value, color = name, group = name )) +\n  stat_summary(geom = \"point\", \n               fun = mean) +\n  stat_summary(geom = \"line\") + \n  stat_summary(geom = \"errorbar\", width = 0.1) +\n  scale_color_manual(values = c(\"red\", \"blue\"),\n                     labels = c(\"Rajada (m/s)\",\n                                \"Velocidade do vento (m/s)\"),\n                     guide = \"legend\") +\n  theme(panel.grid.minor = element_blank(),\n        legend.position = \"bottom\",\n        legend.title = element_blank(),\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 12)) + \n  labs(title = \"Velocidade média mensal do vento em 2022\",\n       subtitle = \"Estação UFSC - Ressacada\",\n       caption = \"Elaboração: Prof. Tiago Olivoto\",\n       x = \"Mês do ano\",\n       y = \"Velocidade (m/s)\")\n\n\n\n\n\n4.12.4 Direção do vento\n\n\n# cria uma tabela de frequência transformando a variável quantitativa direção do vento\n# em uma qualitativa usando a função cut()\n\nfreq &lt;- \ndf_estacao %&gt;% \n  group_by(m) %&gt;% \n  mutate(quadrante = cut(dirvent, \n                         breaks = seq(0, 360, by = 45),\n                         right = FALSE)) |&gt; \n  group_by(m, quadrante) |&gt; # conta as horas por mes e por quadrante\n  count() |&gt; # conta as horas por mes e por quadrante\n  group_by(m) |&gt; # agrupa por mes\n  mutate(percent = n / sum(n)) |&gt; # converte em percentagem\n  select(m, quadrante, percent) |&gt; \n  pivot_wider(names_from = quadrante, values_from = percent) |&gt; \n  set_names(c(\"mes\", paste0(seq(0, 315, by = 45)))) |&gt; \n  column_to_rownames(\"mes\") |&gt; \n  slice(2, 11)\n\n# altera o nome das colunas para pontos cardeais\nnames(freq) &lt;- c(\"N\", \"NE\", \"L\", \"SE\", \"S\", \"SO\", \"O\", \"NO\")\nfreq\n##            N         NE          L         SE         S         SO          O\n## 2  0.2098214 0.08779762 0.04613095 0.04464286 0.1577381 0.07142857 0.09970238\n## 11 0.1319444 0.04305556 0.08750000 0.20138889 0.2250000 0.08472222 0.07361111\n##           NO\n## 2  0.2827381\n## 11 0.1527778\n\n# define o máximo da frequência e o mínimo da frequência\n# isso vai definir o quao expandido e contraído ficará o radar\nmaxmim &lt;- data.frame(rbind(rep(0.4, 8), rep(0, 8)))\nnames(maxmim) &lt;- c(\"N\", \"NE\", \"L\", \"SE\", \"S\", \"SO\", \"O\", \"NO\")\n\n# junta as frequências com os máximos e mínimos\nfreqrad &lt;- rbind(maxmim, freq)\n# inverte a ordem das colunas para ficar certo na rosa dos ventos\nfreqrad &lt;- freqrad[,c(1, seq(8, 2))]\n\nlibrary(fmsb) # pacote para criar o radar\n# https://r-charts.com/ranking/radar-chart/\nareas &lt;- c(rgb(1, 0, 0, 0.3),\n           rgb(0, 1, 0, 0.3))\nradarchart(freqrad,\n           seg = 3,\n           axistype = 4,\n           caxislabels = paste0(c(0, 10, 20, 30), \"%\"),\n           pcol = c(\"red\", \"green\"),\n           pfcol = areas)\nlegend(\"topright\",\n       legend = c(\"Junho\", \"Novembro\"),\n       bty = \"n\",\n       pch = 20,\n       col = areas,\n       text.col = \"grey25\",\n       pt.cex = 2)"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#mapas",
    "href": "RGV410046_08_DATAVIZ.html#mapas",
    "title": "8. Visualização de dados",
    "section": "\n4.13 Mapas",
    "text": "4.13 Mapas\n\n4.13.1 Mapa da américa do sul e Brasil\nO pacote rnaturalearth é uma excelente ferramenta para manter e facilitar a interação com os dados do mapa Natural Earth. Para produção de mapas com o ggplot2, os seguintes pacotes são necessários.\n\n#| out-width: \"100%\"\n\n\n# américa do sul\nlibrary(rnaturalearth)\nlibrary(tidyverse)\nsam &lt;-\n  ne_countries(continent = \"south america\",\n               returnclass = \"sf\",\n               scale = 50)\n\np1 &lt;- \n  ggplot() +\n  geom_sf(data = sam, fill = \"white\") +\n  theme_light() +\n  xlim(c(-90, -35))\n\n# plotar o brasil e destacar santa catarina\nbrazil &lt;- \n  ne_states(country = \"brazil\", returnclass = \"sf\") |&gt; \n  mutate(scat = ifelse(postal == \"SC\", \"SC\", \"Outros\"))\n\np2 &lt;- \n  p1 + \n  geom_sf(data = brazil, aes(fill = scat))\np2\n\n\n\n\n\n4.13.2 Mapa do Brasil e SC, com municípios\n\nsc &lt;- \n  read_municipality(code_muni = \"SC\",\n                    simplified = FALSE,\n                    showProgress = FALSE) |&gt; \n  mutate(floripa = ifelse(name_muni == \"Florianópolis\",\n                          \"Florianópolis\",\n                          \"Outro\"))\n\nUsing year/date 2010\n\np3 &lt;-\n  p1 + \n  geom_sf(data = brazil) +\n  geom_sf(data = sc, aes(fill = floripa)) +\n  xlim(c(-55, -47)) +\n  ylim(c(-30, -25)) +\n  labs(title = \"Mapa do brasil destacando o estado de SC\",\n       caption = \"Produzido com os pkgs geobr e rnaturalearth\",\n       fill = \"\") +\n  theme(legend.position = \"bottom\")\n\nScale for x is already present.\nAdding another scale for x, which will replace the existing scale.\n\np3"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#o-pacote-esquisse",
    "href": "RGV410046_08_DATAVIZ.html#o-pacote-esquisse",
    "title": "8. Visualização de dados",
    "section": "\n4.14 O pacote esquisse",
    "text": "4.14 O pacote esquisse\nO pacote esquisse ajuda a explorar e visualizar dados de forma interativa. Ele é uma interface Shiny para criar gráficos ggplot interativamente usando “arrastar e soltar” para mapear suas variáveis. Pode-se visualizar rapidamente os dados de acordo com seu tipo, exportar para formatos raster (ex., .png, .jpg) ou vetor (ex., .pdf, .eps) e recuperar o código para reproduzir o gráfico.\nPara inciar a criação do gráfico, basta carregar o pacote e executar o comando esquisser(). Uma janela aparecerá, onde será possível importar um conjunto de dados, ou utilizar um conjunto de dados existente no ambiente R.\n\nesquisser()\n\n\nApós selecionar o conjunto de dados, as variáveis existentes ficarão disponíveis para serem mapeadas. Basta clicar e arrastar! Para ter uma maior área de trabalho do pacote, sugere-se definir a opção para que a interface gráfica do pacote seja aberta no navegador. Para isso, rode options(\"esquisse.viewer\" = \"browser\")."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#motivação",
    "href": "RGV410046_08_DATAVIZ.html#motivação",
    "title": "8. Visualização de dados",
    "section": "\n5.1 Motivação",
    "text": "5.1 Motivação\nA densidade de fluxo de fótons fotossintéticos (PPFD) em níveis subótimos ou superótimos pode modificar o acúmulo de biomassa, composição bromatológica e aparência das culturas. Para isso, Olivoto et al. (2018)3 investigaram o efeito de níveis de radiação no crescimento da chicória (Cichorium endivia L. var. latifolia). Os dados disponíveis na aba chicoria do conjunto de dados examples_data.xlsx são relativos a duas variáveis, à saber, matéria seca total (MST) e área foliar (AF) de plantas de chicória cultivadas em diferentes níveis de sombreamento (50, 70, e 100), e avaliados aos 21, 28 e 35 dias após o plantio.\n\ndf &lt;-  import(\"examples_data.xlsx\",\n              sheet = \"chicoria\",\n              setclass = \"tbl\")\ndf\n\n# A tibble: 36 × 5\n   DAP   SOM   REP     MST    AF\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 21DAP 50R   B1     4.31  847.\n 2 21DAP 50R   B2     5.25 1607.\n 3 21DAP 50R   B3     4.50 1320.\n 4 21DAP 50R   B4     4.61 1567.\n 5 21DAP 70R   B1     4.12 1206.\n 6 21DAP 70R   B2     5.52 1863.\n 7 21DAP 70R   B3     5.27 1774.\n 8 21DAP 70R   B4     4.26 1307.\n 9 21DAP 100R  B1     5.24 1203.\n10 21DAP 100R  B2     5.70 1299.\n# ℹ 26 more rows\n\n\nPara lapidar os conhecimentos na construção de gráficos, utilize o pacote ggplot24 e metan5 para solução dos seguintes problemas."
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#problema-1---associação-entre-variáveis",
    "href": "RGV410046_08_DATAVIZ.html#problema-1---associação-entre-variáveis",
    "title": "8. Visualização de dados",
    "section": "\n5.2 Problema 1 - Associação entre variáveis",
    "text": "5.2 Problema 1 - Associação entre variáveis\n\nConsiderando os dados, construa um gráfico de dispersão com a variável AF no eixo x e a variável MST no eixo y, salve o gráfico em um objeto chamado p1.\n\n\np1 &lt;- \n  ggplot(df, aes(AF, MST)) +\n  geom_point()\n\n\nPara melhor compreender a distribuição dos pontos, realize o mapeamento da variável DAP com diferentes cores.\nAltere a legenda do eixo x e y para ‘Área foliar (cm2)’ e ‘Matéria seca (g)’, respectivamente.\nAplique um tema de sua preferência ao tema utilizando qualquer tema definido por theme_*()6.\nArmazene o gráfico em um objeto chamado p2.\n\n\np2 &lt;- \n  ggplot(df, aes(AF, MST, color = DAP)) +\n  geom_point() +\n  labs(x = \"Área foliar (cm2)\",\n       y = \"Matéria seca (g)\")\n\n\nOrganize os gráficos p1 e p2 em um mesmo painel, um ao lado do outro.\n\n\narrange_ggplot(p1, p2)\n\n\n\n\n\nRealize a interpretação do gráfico com relação à associação entre AF e MST.\n\n\nA área foliar e a matéria seca estão positivamente relacionadas, ou seja, há a tendêncida de que o aumento na área foliar venha acompanhado do aumento na matéria seca. No segundo gráfico, é possível identificar que os maiores valores de matéria seca e área foliar foram observados nos 35DAP, e o menores, aos 21DAP.\n\n\nSalve os gráficos em um arquivo chamado dispersão.png, com 3 polegadas de altura e 8 de largura\n\n\nggsave(\"dispersão.png\", width = 8, height = 3)"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#problema-2---variação-dos-dados",
    "href": "RGV410046_08_DATAVIZ.html#problema-2---variação-dos-dados",
    "title": "8. Visualização de dados",
    "section": "\n5.3 Problema 2 - Variação dos dados",
    "text": "5.3 Problema 2 - Variação dos dados\n\nConfeccione um gráfico do tipo boxplot contendo a variável DAP no eixo x e MST no eixo y. Salve o gráfico em um objeto chamado p3.\n\n\np3 &lt;- \n  ggplot(df, aes(DAP, MST)) +\n  geom_boxplot()\n\n\nPara fazer inferências sobre o fator sombreamento, construa um boxplot semelhante, mas agora mapeando a variável SOM com diferentes cores de preenchimento do boxplot. * Inclua uma linha horizontal que represente a média geral da matéria seca.\nSalve o gráfico em um objeto chamado p4.\n\n\np4 &lt;- \n  ggplot(df, aes(DAP, MST, fill = SOM)) +\n  geom_boxplot() +\n  geom_hline(yintercept = mean(df$MST))\n\n\nOrganize os gráficos p3 e p4 em um mesmo painel, um ao lado do outro.\n\n\narrange_ggplot(p3, p4)\n\n\n\n\n\nRealize a interpretação do gráfico com relação à variação da matéria seca total entre os diferentes níveis de radiação dentro de cada dia após o plantio.\n\n\nAos 21DAP foi observada a menor variação entre os níveis de SOM. Aos 28DAP, a diferença entre os níveis de SOM foi mais evidente, onde plantas crescendo em 100R apresentaram um valor mediano de MST maior, mas também a maior variação entre as repetições (comprimento da caixa). Aos 35DAP, a diferença entre as radiações torna-se mais evidente. Também, pode-se observar que as variações entre as repetições do 100R e 50R foram menores se comparado aos 28DAP (menor comprimento da caixa).\n\n\nSalve os boxplots em um arquivo chamado boxplot.png.\n\n\nggsave(\"boxplot.png\")"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#problema-3---médias",
    "href": "RGV410046_08_DATAVIZ.html#problema-3---médias",
    "title": "8. Visualização de dados",
    "section": "\n5.4 Problema 3 - Médias",
    "text": "5.4 Problema 3 - Médias\n\nConfeccione um gráfico de barras mostrando a média da variável AF no eixo y para cada dia após o plantio (DAP) no eixo x.\nDefina os limites do eixo y de 0 até 6000.\nSalve o gráfico em um objeto chamado p5.\n\n\nDica: a função plot_bars() do pacote metan pode ser útil.\n\n\np5 &lt;- \n  plot_bars(df,\n            x = DAP,\n            y = AF,\n            y.lim = c(0, 6000))\n\n# versão ggplot2\np5.2 &lt;- \n  ggplot(df, aes(DAP, AF)) +\n  geom_bar(stat = \"summary\") +\n  ylim(c(0, 6000))\n\n\nAssumindo que as médias da AF precisam ser apresentadas para cada combinação de DAP e SOM, mapeie a variável SOM com diferentes cores de preenchimento no gráfico de barras.\nMude os títulos dos eixos x e y para “Dias após o plantio (DAP)” e “Área foliar (cm2)”, respectivamente.\nDefina os limites do eixo y de 0 até 6000.\nArmazene o gráfico em um objeto chamado p6.\nOrganize os gráficos p5 e p6 em um único painel\nSalve os gráficos de barra em uma imagem chamada barras.png.\n\n\nDica: a função plot_factbars() do pacote metan pode ser útil.\n\n\np6 &lt;- \n  plot_factbars(df, DAP, SOM,\n                resp = AF,\n                y.lim = c(0, 6000),\n                xlab = \"Dias após o plantio (DAP)\",\n                ylab = \"Área foliar (cm2)\")\n\n# versão ggplot2\np6.2 &lt;- \n  ggplot(df, aes(DAP, AF, fill = SOM)) +\n  geom_bar(stat = \"summary\",\n           fun = \"mean\",\n           width = 0.7,\n           position = position_dodge()) +\n  stat_summary(fun.data = mean_se,\n               geom = \"errorbar\",\n               width = 0.2,\n               position = position_dodge( width = 0.7)) +\n  labs(x = \"Dias após o plantio (DAP)\",\n       y = \"Área foliar (cm2)\") +\n  ylim(c(0, 6000))\n\n\nOrganize os gráficos p5 e p6 em um mesmo painel, um ao lado do outro.\n\n\narrange_ggplot(p5, p6)\n\n\n\n\n\nRealize a interpretação do gráfico com relação à área foliar nos diferentes níveis de radiação ao longo dos dias após o plantio.\n\n\nA média da área foliar foi mais semelhante entre os níveis de radiação aos 21DAP. Considerando o erro padrão da média como uma medida de significância, pode-se afirmar que aos 21DAP as médias do 50R e 70R foram estatisticamente iguais. Aos 35DAP, a área foliar das plantas crescendo com 50% de radiação foi menor que àquelas crescendo em pleno sol (100R) e com 70% de radiação (70R).\n\n\nSalve os boxplots em um arquivo chamado barras.png.\n\n\nggsave(\"barras.png\")"
  },
  {
    "objectID": "RGV410046_08_DATAVIZ.html#footnotes",
    "href": "RGV410046_08_DATAVIZ.html#footnotes",
    "title": "8. Visualização de dados",
    "section": "Footnotes",
    "text": "Footnotes\n\nWICKHAM, H. Ggplot2 : elegant graphics for data analysis: Springer, 2009.↩︎\nhttps://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html↩︎\nOLIVOTO, T. et al. Photosynthetic photon flux density levels affect morphology and bromatology in Cichorium endivia L. var. latifolia grown in a hydroponic system. Scientia Horticulturae, v. 230, p. 178–185, 7 jan. 2018.↩︎\nWICKHAM, H. ggplot2: Elegant Graphics for Data Analysis. New York: Springer, 2016.↩︎\nOLIVOTO, T.; LÚCIO, A. D. metan: An R package for multi‐environment trial analysis. Methods in Ecology and Evolution, v. 11, n. 6, p. 783–789, 2020↩︎\nO pacote ggthemes (https://mran.microsoft.com/snapshot/2015-04-01/web/packages/ggthemes/vignettes/ggthemes.html) pode ser utilizado para aumentar o leque de possibilidades.↩︎"
  },
  {
    "objectID": "RGV410046_06_MUTACAO.html",
    "href": "RGV410046_06_MUTACAO.html",
    "title": "6. Mutação",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_06_MUTACAO.html#ifelse-com-r-base",
    "href": "RGV410046_06_MUTACAO.html#ifelse-com-r-base",
    "title": "6. Mutação",
    "section": "\n6.1 ifelse() com R base",
    "text": "6.1 ifelse() com R base\nA função ifelse() retorna um valor com a mesma forma de test que é preenchido com elementos selecionados de yes ou no, dependendo se o elemento de test é TRUE ou FALSE. Para criação da nova coluna baseado nas notas em notas, utiliza-se a seguinte abordagem. Note que como temos três classes (aprovado, reprovado ou exame) e ifelse() somente retorna duas dependendo se o teste é TRUE ou FALSE, precisamos aninhar ifelse()s.\n\nclasse &lt;- \n  transform(notas,\n            condicao = ifelse(nota &lt; 4,\n                           yes = \"reprovado\", \n                           no = ifelse(nota &gt;= 4 & nota &lt; 7,\n                                       yes = \"exame\",\n                                       no = \"aprovado\")))\nclasse[order(classe$nota, decreasing = TRUE), ]\n\n     aluno nota  condicao\n9   Aluno9  9.7  aprovado\n3   Aluno3  9.4  aprovado\n8   Aluno8  8.7  aprovado\n6   Aluno6  7.9  aprovado\n2   Aluno2  7.8  aprovado\n7   Aluno7  6.7     exame\n4   Aluno4  5.0     exame\n1   Aluno1  4.4     exame\n10 Aluno10  3.8 reprovado\n5   Aluno5  3.7 reprovado"
  },
  {
    "objectID": "RGV410046_06_MUTACAO.html#case_when-com-dplyr",
    "href": "RGV410046_06_MUTACAO.html#case_when-com-dplyr",
    "title": "6. Mutação",
    "section": "\n6.2 case_when() com dplyr",
    "text": "6.2 case_when() com dplyr\ncase_when() pode ser vista como uma versão vetorizada de ifelse() que permite que você avalie várias instruções. Se nenhum caso corresponder, NA será retornado. Esta função é particularmente útil dentro da função mutate() quando você quer criar uma nova variável que depende de uma combinação complexa de variáveis existentes.\nA função é baseada em uma sequência de fórmulas de dois lados. O lado esquerdo (LHS) determina o teste; O lado direito (RHS) fornece o valor de substituição.\n\nnotas |&gt; \n  mutate(condicao = case_when(\n    nota &lt; 4 ~ \"reprovado\",\n    between(nota, 4, 6.99999999) ~ \"exame\", # mesmo que nota &gt;= 4 & nota &lt; 7\n    TRUE ~ \"aprovado\" # TRUE: o que não foi incluso nas duas avaliações anteriores\n  )) |&gt; \n  arrange(desc(nota))\n\n     aluno nota  condicao\n1   Aluno9  9.7  aprovado\n2   Aluno3  9.4  aprovado\n3   Aluno8  8.7  aprovado\n4   Aluno6  7.9  aprovado\n5   Aluno2  7.8  aprovado\n6   Aluno7  6.7     exame\n7   Aluno4  5.0     exame\n8   Aluno1  4.4     exame\n9  Aluno10  3.8 reprovado\n10  Aluno5  3.7 reprovado\n\n\nNeste exemplo, o conjunto de dados maize é utilizado para mostrar como uma variável qualitativa nominal pode ser criada utilizando a função case_when(). A nova variável será criada dependendo dos valores de APLA, AIES ou CESP. Ao agrupar pela nova variável categórica criada e utilizar a função slice_sample(), um exemplo de cada nível é amostrado aleatoriamente.\n\nset.seed(10)\n\nmaize |&gt; \n  mutate(\n    CASO = case_when(\n      MGRA &gt; 280 | APLA_PLANT &lt; 1.3 | NGRA &gt; 820 ~  \"Selecionar\",\n      APLA_PLANT &gt; 2.3 ~ \"Alto\",\n      MGRA &lt; 130 ~ \"Pouco produtivo\",\n      TRUE ~ \"Outro\"\n    )\n  ) |&gt; \n  group_by(CASO) |&gt; \n  slice_sample(n = 1)\n\n# A tibble: 4 × 11\n# Groups:   CASO [4]\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA CASO    \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   \n1 A1    H10   III         3.11       1.86  15.5  50.2 194.   405.   479 Alto    \n2 A3    H2    II          2.04       0.92  14.7  47.2 130.   362.   360 Outro   \n3 A3    H9    I           2.24       1.17  13    42.6  92.6  384.   241 Pouco p…\n4 A3    H2    III         0          1.25  17.8  51.6 196.   348.   562 Selecio…\n\nt &lt;- \nmaize |&gt; \n  mutate(test = case_when(MGRA &gt; 280 ~ MGRA *1000,\n                          TRUE ~ MGRA))\n\n\n\n\n\n\n\n\nAbordagem R base\n\n\n\nO seguinte exemplo realiza o mesmo procedimento de criação da variável categórica utilizando as funções R base transform() e ifelse().\n\nmilho2 &lt;- \ntransform(maize, \n          CASO = ifelse(MGRA &gt; 280 | APLA_PLANT &lt; 1.3 | NGRA &gt; 820, \"Selecionar\",\n                        ifelse(APLA_PLANT &gt; 2.3, \"Alto\",\n                               ifelse(MGRA &lt; 130, \"Pouco produtivo\",\n                                      \"Outro\"))))\n\n# cria uma lista onde cada elemento é um nível de CASO\ncasos &lt;- split(milho2, milho2$CASO)\n\n\n# percorre a lista e amostra uma linha aleatória de cada uma\n# junta com rbind()\n\nset.seed(10)\ndo.call(rbind,\n  lapply(casos, function(x){\n    x[sample(nrow(x), 1), ]\n  })\n)\n\n                AMB HIB REP APLA_PLANT AIES_PLANT CESP  DIES      MGRA      MMG\nAlto             A1 H10 III       3.01       1.64 17.0 54.27 210.78954 419.0647\nOutro            A3  H3   I       2.28       1.19 14.3 51.62 162.09701 305.2674\nPouco produtivo  A3  H9  II       1.80       0.58 12.4 42.47  73.97816 271.9785\nSelecionar       A3  H2 III       0.00       1.25 17.8 51.57 195.59343 348.0310\n                NGRA            CASO\nAlto             503            Alto\nOutro            531           Outro\nPouco produtivo  272 Pouco produtivo\nSelecionar       562      Selecionar"
  },
  {
    "objectID": "RGV410046_06_MUTACAO.html#exemplo-de-aplicação",
    "href": "RGV410046_06_MUTACAO.html#exemplo-de-aplicação",
    "title": "6. Mutação",
    "section": "\n6.3 Exemplo de aplicação",
    "text": "6.3 Exemplo de aplicação\n\n\n\n\n\n\nCálculo de Graus-dia (GD)\n\n\n\nSegundo Ometto (1981)1, existe uma temperatura mínima (Tm, ºC) para acionar os dispositivos metabólicos da planta, que é denominada de temperatura basal inferior (Tb, ºC). Somente acima desta temperatura a planta pode se desenvolver. O mesmo autor ressalta, contudo, que a planta também possui uma temperatura basal superior (TB, ºC), acima da qual há um estancamento das atividades metabólicas, prejudicando seu desenvolvimento.\nO método de Arnold (1959)2 considera somente a Tb no cálculo dos graus-dia (GD). Neste método, o GD é calculado como a diferença entre entre a temperatura média diária e a temperatura basal inferior, ou seja\n\\[\nGD = \\frac{TM + Tm}{2} - Tb\n\\] O método proposto por Ometto (1981), considera a Tb e a TB no cálculo dos graus dia. Neste método, a soma térmica apresenta cinco condicionantes, cada uma com determinada equação (Equações 2 a 6) para cálculo de GD:\n\\[\n\\begin{aligned}&\\mathrm{TB}&gt;\\mathrm{TM}&gt;\\mathrm{Tm}&gt;\\mathrm{Tb} \\quad \\mathrm{GD}=\\frac{\\mathrm{TM}-\\mathrm{Tm}}{2}+\\mathrm{Tm}-\\mathrm{Tb}, \\\\&\\mathrm{TB}&gt;\\mathrm{TM}&gt;\\mathrm{Tb}&gt;\\mathrm{Tm} \\quad \\mathrm{GD}=\\frac{(\\mathrm{TM}-\\mathrm{Tb})^2}{2(\\mathrm{TM}-\\mathrm{Tm})}, \\\\&\\mathrm{TB}&gt;\\mathrm{Tb}&gt;\\mathrm{TM}&gt;\\mathrm{Tm} \\quad \\mathrm{GD}=0, \\\\&\\mathrm{TM}&gt;\\mathrm{TB}&gt;\\mathrm{Tm}&gt;\\mathrm{Tb} \\\\&\\mathrm{GD}=\\frac{2(\\mathrm{TM}-\\mathrm{Tm})(\\mathrm{Tm}-\\mathrm{Tb})+(\\mathrm{TM}-\\mathrm{Tm})^2-(\\mathrm{TM}-\\mathrm{TB})}{2(\\mathrm{TM}-\\mathrm{Tm})}, \\\\&\\mathrm{TM}&gt;\\mathrm{TB}&gt;\\mathrm{Tb}&gt;\\mathrm{Tm} \\quad \\mathrm{GD}=\\frac{1}{2} . \\frac{(\\mathrm{TM}-\\mathrm{Tb})^2-(\\mathrm{TM}-\\mathrm{TB})^2}{\\mathrm{TM}-\\mathrm{Tm}},\\end{aligned}\n\\]\nComo exemplo motivacional,Os dados contidos em estacao_fazenda.csv contém informações de variáveis climáticas obtidas em sensores automáticos de uma estação meteorológica localizada na Fazenda Experimental da Ressacada (UFSC). Os dados são em escala horária, obtidos do dia 01/01/2022 a 28/11/2022, totalizando 7957 observações.\n\nlibrary(lubridate) # trabalhar com datas\ndf_estacao &lt;-  \n  import(\"estacao_fazenda.csv\", setclass = \"tbl\") |&gt; \n  mutate(dia = dmy(dia))\ndf_estacao\n\n# A tibble: 8,759 × 12\n   dia            m  prec  tmax  tmed  tmin urmax urmed urmin dirvent velvent\n   &lt;date&gt;     &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 2022-01-01     1     0  21.2  20.6  20.2   100  99.5  99.0     0     0    \n 2 2022-01-01     1     0  20.5  19.8  19.4   100  99.9  99.6     0     0    \n 3 2022-01-01     1     0  19.7  19.4  19.0   100 100.   99.9     0     0    \n 4 2022-01-01     1     0  20.0  19.2  18.7   100 100   100       0     0    \n 5 2022-01-01     1     0  20.5  20.2  19.8   100 100   100       0     0    \n 6 2022-01-01     1     0  20.7  20.2  19.9   100 100   100      79.8   0.331\n 7 2022-01-01     1     0  20.2  19.7  19.1   100 100   100       0     0    \n 8 2022-01-01     1     0  20.0  19.5  19.1   100 100   100       0     0    \n 9 2022-01-01     1     0  22.1  21.2   0     100  99.3   0       0     0    \n10 2022-01-01     1     0  26.0  24.3  22.1   100  89.0  78.6   287.    0.087\n# ℹ 8,749 more rows\n# ℹ 1 more variable: rajada &lt;dbl&gt;\n\n\nNestes dados, tmax é a temperatura máxima (TM) e tmin é a temperatura mínima (Tm).\nConsiderando os dados apresentados\n\nCrie um conjunto de dados chamado df_temps contendo, para cada dia, a temperatura máxima como sendo a máxima das máximas e a temperatura mínima como sendo a mínima das mínimas. Nomeie as colunas da seguinte forma:\n\ndia: o dia;\ntmin: temperatura mínima;\ntmax: temperatura máxima.\n\n\nCrie uma função chamada gd_arnold() para calcular o grau-dia pelo método de Arnold (1959);\nCrie uma função chamada gd_ometto() para calcular o grau-dia pelo método de Ometto (1981);\nConsiderando uma cultura com TB = 32 e Tb = 12, calcule\n\nO grau-dia considerando o método de Arnold (1959)\nO grau-dia considerando o método de Ometto (1981)\n\n\nRealize uma mutação do conjunto df_temps incluindo\n\nDuas novas colunas (gd_arnold e gd_ometto), contendo os graus-dia calculados pelos métodos de Arnold (1959) e Ometto (1981), respectivamente. OBS. Para essa mutação, utilize rowise() para que a checagem de temperaturas máximas e mínimas dentro de mutate() seja realizada em de cada dia (não entre os dias).\nDuas novas colunas gd_arnold_ac e gd_ometto_ac contendo os graus-dia acumulados em cada dia do período dos dados."
  },
  {
    "objectID": "RGV410046_06_MUTACAO.html#footnotes",
    "href": "RGV410046_06_MUTACAO.html#footnotes",
    "title": "6. Mutação",
    "section": "Footnotes",
    "text": "Footnotes\n\nOMETTO, J. C. Bioclimatologia vegetal. São Paulo: Agronômica Ceres 1981. 440p.↩︎\nARNOLD, C. Y. The determination and significance of the base temperature in a linear heat unit system. Proceedings of the American Society for Horticultural Science, Alexandria, v. 74, n.1 p. 430-445, 1959↩︎"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html",
    "href": "RGV410046_04_SELECAO.html",
    "title": "4. Seleção e filtragem",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#selecionar-colunas",
    "href": "RGV410046_04_SELECAO.html#selecionar-colunas",
    "title": "4. Seleção e filtragem",
    "section": "\n4.1 Selecionar colunas",
    "text": "4.1 Selecionar colunas\n\n\n\n\nA função select() do pacote dplyr pode ser usada para selecionar colunas de um conjunto de dados com base em seu nome (por exemplo, a:f seleciona todas as colunas de a à esquerda a f à direita). Você também pode usar funções de predicado como is.numeric para selecionar variáveis com base em suas propriedades. As seleções do Tidyverse implementam um dialeto R onde os operadores facilitam a seleção de variáveis:\n\n\n: para selecionar um intervalo de variáveis consecutivas.\n\n! para tomar o complemento de um conjunto de variáveis.\n\n& e | para selecionar a interseção ou a união de dois conjuntos de variáveis.\n\nc() para combinar seleções.\n\n\n4.1.1 Com base em seus nomes\n\nmaize &lt;- \n  import(\"examples_data.xlsx\",\n         sheet = \"maize\",\n         setclass = \"tbl\")\n# para evitar uma saída longa\ndf &lt;- maize |&gt; slice(1:5)\n\n# lista de nomes\ndf |&gt; select(AMB, HIB, REP)\n\n# A tibble: 5 × 3\n  AMB   HIB   REP  \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 A1    H1    I    \n2 A1    H1    I    \n3 A1    H1    I    \n4 A1    H1    I    \n5 A1    H1    I    \n\n# sequência de nomes\ndf |&gt; select(AMB:REP)\n\n# A tibble: 5 × 3\n  AMB   HIB   REP  \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 A1    H1    I    \n2 A1    H1    I    \n3 A1    H1    I    \n4 A1    H1    I    \n5 A1    H1    I    \n\n# vector de posições\ndf |&gt; select(1:3)\n\n# A tibble: 5 × 3\n  AMB   HIB   REP  \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 A1    H1    I    \n2 A1    H1    I    \n3 A1    H1    I    \n4 A1    H1    I    \n5 A1    H1    I    \n\n# negar a seleção\ndf |&gt; select(!c(AMB:REP))\n\n# A tibble: 5 × 7\n  APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1       2.45       2.39  16.9  52.1  228.  375.    NA\n2       2.5        1.43  14.4  50.7  187.  437.   427\n3       2.69       1.52  16.5  54.7  230.  464.   497\n4       2.8        1.64  16.8  52.0  213.  408.   523\n5       2.62       1.55  15.9  51.6  224.  406.   551\n\n\n\n4.1.2 Com base na classe\nA função where() aplica uma função a todas as variáveis e seleciona aquelas para as quais a função retorna TRUE. Assim, podemos selecionar facilmente colunas com base em sua classe\n\n# seleciona variáveis numéricas\ndf |&gt; select(where(is.numeric))\n\n# A tibble: 5 × 7\n  APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1       2.45       2.39  16.9  52.1  228.  375.    NA\n2       2.5        1.43  14.4  50.7  187.  437.   427\n3       2.69       1.52  16.5  54.7  230.  464.   497\n4       2.8        1.64  16.8  52.0  213.  408.   523\n5       2.62       1.55  15.9  51.6  224.  406.   551\n\n# seleciona variáveis não numéricas\ndf |&gt; select(!where(is.numeric))\n\n# A tibble: 5 × 3\n  AMB   HIB   REP  \n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 A1    H1    I    \n2 A1    H1    I    \n3 A1    H1    I    \n4 A1    H1    I    \n5 A1    H1    I    \n\n\n\n4.1.3 Select helpers\nEssas funções permitem selecionar variáveis com base em seus nomes.\n\n\nstarts_with(): começa com um prefixo\n\n\ndf |&gt; select(starts_with(\"C\"))\n\n# A tibble: 5 × 1\n   CESP\n  &lt;dbl&gt;\n1  16.9\n2  14.4\n3  16.5\n4  16.8\n5  15.9\n\n\n\n\nends_with(): termina com um prefixo\n\n\ndf |&gt; select(ends_with(\"S\"))\n\n# A tibble: 5 × 1\n   DIES\n  &lt;dbl&gt;\n1  52.1\n2  50.7\n3  54.7\n4  52.0\n5  51.6\n\n# variáveis que começam com M e terminam com A\ndf |&gt; select(starts_with(\"M\") & ends_with(\"A\"))\n\n# A tibble: 5 × 1\n   MGRA\n  &lt;dbl&gt;\n1  228.\n2  187.\n3  230.\n4  213.\n5  224.\n\n# variáveis que começam com M ou terminam com A\ndf |&gt; select(starts_with(\"M\") | ends_with(\"A\"))\n\n# A tibble: 5 × 3\n   MGRA   MMG  NGRA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  228.  375.    NA\n2  187.  437.   427\n3  230.  464.   497\n4  213.  408.   523\n5  224.  406.   551\n\n\n\n\ncontains(): contém uma string literal\n\nSe as variáveis no conjunto de dados tiverem um padrão com diferenças entre um grupo de variáveis, podemos usar o código a seguir para selecionar variáveis com um padrão.\n\ndf |&gt; select(contains(\"PLANT\"))\n\n# A tibble: 5 × 2\n  APLA_PLANT AIES_PLANT\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       2.45       2.39\n2       2.5        1.43\n3       2.69       1.52\n4       2.8        1.64\n5       2.62       1.55\n\n\n\n\nmatches(): corresponde a uma expressão regular\n\nSeleções mais sofisticadas podem ser feitas usando matches(). Supondo que gostaríamos de selecionar as variáveis que começam com “A” e tem a segunda letra entre “A” e “M”, usaríamos algo como\n\ndf |&gt; select(matches(\"^A[A-M]\"))\n\n# A tibble: 5 × 2\n  AMB   AIES_PLANT\n  &lt;chr&gt;      &lt;dbl&gt;\n1 A1          2.39\n2 A1          1.43\n3 A1          1.52\n4 A1          1.64\n5 A1          1.55\n\n\n\n\none_of(): variáveis no vetor de caracteres.\n\n\nvars &lt;- c(\"TESTE\", \"CESP\", \"NGRA\", \"NAO_TEM\")\ndf |&gt; select(one_of(vars))\n\nWarning: Unknown columns: `TESTE`, `NAO_TEM`\n\n\n# A tibble: 5 × 2\n   CESP  NGRA\n  &lt;dbl&gt; &lt;dbl&gt;\n1  16.9    NA\n2  14.4   427\n3  16.5   497\n4  16.8   523\n5  15.9   551\n\n\n\n\neverything(): todas as variáveis.\n\n\ndf |&gt; select(everything())\n\n# A tibble: 5 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H1    I           2.45       2.39  16.9  52.1  228.  375.    NA\n2 A1    H1    I           2.5        1.43  14.4  50.7  187.  437.   427\n3 A1    H1    I           2.69       1.52  16.5  54.7  230.  464.   497\n4 A1    H1    I           2.8        1.64  16.8  52.0  213.  408.   523\n5 A1    H1    I           2.62       1.55  15.9  51.6  224.  406.   551"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#extrair-colunas",
    "href": "RGV410046_04_SELECAO.html#extrair-colunas",
    "title": "4. Seleção e filtragem",
    "section": "\n4.2 Extrair colunas",
    "text": "4.2 Extrair colunas\nNo R base, para extrair colunas de um data frame usamos $. A função pull() é semelhante a $, mas é mais fácil de ser utilizada com pipes. Para seleção, podemos especificar uma variável como:\n\num nome de variável literal\num inteiro positivo, dando a posição contando a partir da esquerda\num inteiro negativo, dando a posição contando a partir da direita.\nO padrão retorna a última coluna (supondo que seja a coluna que você criou mais recentemente).\n\nNote a diferença.\n\ndf$MGRA\n\n[1] 228.3716 186.6627 230.3904 213.4960 223.6949\n\n# padrão é a última coluna\ndf |&gt; pull()\n\n[1]  NA 427 497 523 551\n\n# selecionar variável com base no nome\ndf |&gt; pull(MGRA)\n\n[1] 228.3716 186.6627 230.3904 213.4960 223.6949\n\n# selecionar variável com base na sua posição\ndf |&gt; pull(5)\n\n[1] 2.39 1.43 1.52 1.64 1.55"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#realocar-colunas-avançado",
    "href": "RGV410046_04_SELECAO.html#realocar-colunas-avançado",
    "title": "4. Seleção e filtragem",
    "section": "\n4.3 Realocar colunas (Avançado)",
    "text": "4.3 Realocar colunas (Avançado)\nPara reordenar colunas em um data frame, podemos utilizar a função relocate() do pacote dplyr. Ela altera as posições das colunas, usando a mesma sintaxe que select() para facilitar a movimentação de blocos de colunas de uma só vez.\n\nrelocate(.data, ..., .before = NULL, .after = NULL)\n\nNesta função, as variáveis em … são movidas para antes de .before ou depois de .after.\n\ndf |&gt; relocate(NGRA, .before = APLA_PLANT)\n\n# A tibble: 5 × 10\n  AMB   HIB   REP    NGRA APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H1    I        NA       2.45       2.39  16.9  52.1  228.  375.\n2 A1    H1    I       427       2.5        1.43  14.4  50.7  187.  437.\n3 A1    H1    I       497       2.69       1.52  16.5  54.7  230.  464.\n4 A1    H1    I       523       2.8        1.64  16.8  52.0  213.  408.\n5 A1    H1    I       551       2.62       1.55  15.9  51.6  224.  406.\n\ndf |&gt; relocate(contains(\"_PLANT\"), .after = last_col())\n\n# A tibble: 5 × 10\n  AMB   HIB   REP    CESP  DIES  MGRA   MMG  NGRA APLA_PLANT AIES_PLANT\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 A1    H1    I      16.9  52.1  228.  375.    NA       2.45       2.39\n2 A1    H1    I      14.4  50.7  187.  437.   427       2.5        1.43\n3 A1    H1    I      16.5  54.7  230.  464.   497       2.69       1.52\n4 A1    H1    I      16.8  52.0  213.  408.   523       2.8        1.64\n5 A1    H1    I      15.9  51.6  224.  406.   551       2.62       1.55\n\ndf |&gt; relocate(where(is.numeric), .before = where(is.character))\n\n# A tibble: 5 × 10\n  APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA AMB   HIB   REP  \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1       2.45       2.39  16.9  52.1  228.  375.    NA A1    H1    I    \n2       2.5        1.43  14.4  50.7  187.  437.   427 A1    H1    I    \n3       2.69       1.52  16.5  54.7  230.  464.   497 A1    H1    I    \n4       2.8        1.64  16.8  52.0  213.  408.   523 A1    H1    I    \n5       2.62       1.55  15.9  51.6  224.  406.   551 A1    H1    I"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#selecionar-linhas-com-base-em-seus-valores",
    "href": "RGV410046_04_SELECAO.html#selecionar-linhas-com-base-em-seus-valores",
    "title": "4. Seleção e filtragem",
    "section": "\n5.1 Selecionar linhas com base em seus valores",
    "text": "5.1 Selecionar linhas com base em seus valores\nUtilizando a função filter() é possivel filtrar as linhas de um conjunto de dados com base no valor de suas variáveis. No primeiro exemplo, selecionaremos as linhas onde o valor da variável MGRA é maior que 280.\n\nmaize %&gt;% \n  filter(MGRA &gt; 280)\n\n# A tibble: 4 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H6    I           2.92       1.64  18    56.0  289.  393.   734\n2 A1    H10   I           2.92       1.61  20.3  55.4  283.  441.   641\n3 A1    H13   II          2.47       1.28  15.3  53.0  291.  417.   698\n4 A4    H10   I           2.65       1.47  14    50.3  287.  275.   493\n\n\nNo segundo exemplo, selecionaremos apenas as linhas onde a MGRA é maior que 220 OU a APLA é menor que 1.3 OU o NGRA é maior que 820.\n\nmaize %&gt;% \n  filter(MGRA &gt; 280 | APLA_PLANT &lt; 1.3 | NGRA &gt; 820)\n\n# A tibble: 13 × 10\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A1    H6    I           2.92       1.64  18    56.0 289.   393.   734\n 2 A1    H10   I           2.92       1.61  20.3  55.4 283.   441.   641\n 3 A1    H13   II          2.47       1.28  15.3  53.0 291.   417.   698\n 4 A2    H8    II          1.03       0.69  10.8  44.8  94.8  277.   342\n 5 A2    H10   III         1.09       0.92  15    47.6 166.   299.   555\n 6 A2    H13   I           0          1.26  15.1  51.4 173.   375.   462\n 7 A3    H2    III         0          1.25  17.8  51.6 196.   348.   562\n 8 A3    H5    II          0          0.95  14.4  49.7 135.   213.   635\n 9 A3    H10   I           1.04       0.71  14.8  45.5 112.   265.   423\n10 A3    H11   I           1          0.65  14.5  43.6 120.   210.   571\n11 A4    H8    I           2.65       1.67  18    50   277.   251.   903\n12 A4    H8    I           2.95       1.7   18.6  52.9 249.   302.   824\n13 A4    H10   I           2.65       1.47  14    50.3 287.   275.   493\n\n\nNo último exemplo, selecionaremos apenas as linhas onde MGRA é maior que é maior que 220 E a APLA é menor que 2.\n\nmaize %&gt;% \n  filter(MGRA &gt; 220 & APLA_PLANT &lt; 2)\n\n# A tibble: 1 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H6    II          1.97       1.63  17.1  54.7  230.  375.   614\n\n\nIsto é aproximadamente equivalente ao seguinte código R base.\n\nmaize[maize$MGRA &gt; 220 & maize$APLA_PLANT &lt; 2, ]\n\nVocê também pode usar filter() para remover grupos inteiros. Por exemplo, o código a seguir elimina todas as linhas que contém o híbrido “H1”.\n\nmaize |&gt; filter(HIB != \"H1\")\n\n# A tibble: 720 × 10\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A1    H2    I           2.45       1.24  17.7  54.7 255.   422.   604\n 2 A1    H2    I           2.41       1.32  15    50.5 198.   369.   537\n 3 A1    H2    I           2.62       1.16  10    47.5  94.5  380.   249\n 4 A1    H2    I          NA          1.18  16.1  52.3 213.   331.   643\n 5 A1    H2    I           2.65       1.21  16.6  53.2 228.   409.   558\n 6 A1    H2    II          2.95       1.55  14.5  49.2 178.   258.   689\n 7 A1    H2    II          2.95       1.39  15.5  54.7 233.   284.   818\n 8 A1    H2    II          2.92       1.4   14    46.7 174.   288.   602\n 9 A1    H2    II          2.86       1.34  16.1  55.3 273.   356.   767\n10 A1    H2    II          2.84       1.35  15.5  51.6 204.   335.   607\n# ℹ 710 more rows\n\n# seleciona somente os híbridos H1 e H2\nmaize |&gt; filter(HIB  %in%  c(\"H1\", \"H2\"))\n\n# A tibble: 120 × 10\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A1    H1    I           2.45       2.39  16.9  52.1 228.   375.    NA\n 2 A1    H1    I           2.5        1.43  14.4  50.7 187.   437.   427\n 3 A1    H1    I           2.69       1.52  16.5  54.7 230.   464.   497\n 4 A1    H1    I           2.8        1.64  16.8  52.0 213.   408.   523\n 5 A1    H1    I           2.62       1.55  15.9  51.6 224.   406.   551\n 6 A1    H1    II          2.12       1.8   15    51.4 203.   383.   529\n 7 A1    H1    II          3.15       1.78  10.9  NA    75.2  256.   294\n 8 A1    H1    II          2.97       1.84  15    53.4 204.   387.   528\n 9 A1    H1    II          3.1        1.78  13.6  50.8 187.   348.   538\n10 A1    H1    II          3.02       1.6   16.3  53.9 250.   430.   582\n# ℹ 110 more rows"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#selecionar-linhas-com-base-em-sua-posição",
    "href": "RGV410046_04_SELECAO.html#selecionar-linhas-com-base-em-sua-posição",
    "title": "4. Seleção e filtragem",
    "section": "\n5.2 Selecionar linhas com base em sua posição",
    "text": "5.2 Selecionar linhas com base em sua posição\nA função slice() permite indexar linhas por seus locais (inteiros). Ele permite selecionar, remover e duplicar linhas. Ele é acompanhado por vários auxiliares para casos de uso comuns:\n\n\nslice_head() e slice_tail() selecionam a primeira ou a última linha.\n\nslice_sample() seleciona linhas aleatoriamente.\n\nslice_min() e slice_max() selecionam linhas com valores mais altos ou mais baixos de uma variável.\n\n\n# selciona as primeiras três linhas\nmaize |&gt; slice(1:3)\n\n# A tibble: 3 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H1    I           2.45       2.39  16.9  52.1  228.  375.    NA\n2 A1    H1    I           2.5        1.43  14.4  50.7  187.  437.   427\n3 A1    H1    I           2.69       1.52  16.5  54.7  230.  464.   497\n\n# cinco linhas aleatórias\nmaize |&gt; slice_sample(n = 5)\n\n# A tibble: 5 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H9    I          NA          1.76  11.9  51.0  125.  423.   295\n2 A1    H6    I           2.91       1.47  17.1  57.3  280.  420.   665\n3 A2    H2    II          3.06       1.91  15    54.4  198.  501.   396\n4 A4    H2    II          2.7        1.52  16.8  50.0  203.  363.   559\n5 A1    H13   III         3.06       1.93  14.4  54.0  183.  382.   478\n\n# dois menores valores de MGRA\nmaize |&gt; slice_min(n = 2, MGRA)\n\n# A tibble: 2 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A1    H9    III         2.72       1.54  11    42.8  58.5  295.   198\n2 A2    H8    I           1.92       0.63  12.1  39.7  59.5  243.   245\n\n# maior valor de NGRA\nmaize |&gt; slice_max(n = 1, NGRA)\n\n# A tibble: 1 × 10\n  AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 A4    H8    I           2.65       1.67    18    50  277.  251.   903"
  },
  {
    "objectID": "RGV410046_04_SELECAO.html#ordenar-linhas-com-base-em-seus-valores",
    "href": "RGV410046_04_SELECAO.html#ordenar-linhas-com-base-em-seus-valores",
    "title": "4. Seleção e filtragem",
    "section": "\n5.3 Ordenar linhas com base em seus valores",
    "text": "5.3 Ordenar linhas com base em seus valores\nA função arrange() é utilizada para ordenar as linhas de um tibble (ou data.frames) com base em uma expressão envolvendo suas variáveis.\n\n# ordena as linhas com base na variável CESP (crescente)\nmaize |&gt; arrange(CESP)\n\n# A tibble: 780 × 10\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A1    H9    I          NA          1.51 0.800  54.0 224.   420.   533\n 2 A1    H8    I           2.6        1.4  5.9    52.2 225.   383.   588\n 3 A3    H8    III         1.86       0.96 7.5    40.8  73.0  293.   249\n 4 A1    H5    II          2.83       1.82 8.2    43.2  94.6  326.   290\n 5 A4    H3    II          2.37       1.12 8.2    47.4  96.0  256.   375\n 6 A2    H9    I           2.02       1.11 8.7    46.7  61.2  312.   196\n 7 A4    H3    II          2.22       1.02 8.9    41.6  77.8  218.   357\n 8 A3    H1    III         2.45       1.29 9      51.0  78.9  503.   157\n 9 A2    H3    I           2.82       1.87 9.3    47.2 105.   294.   358\n10 A1    H2    III         2.86       1.52 9.4    51.2  91.0  225.   405\n# ℹ 770 more rows\n\n# ordena as linhas com base na variável CESP (decrescente)\nmaize |&gt; arrange(desc(CESP))\n\n# A tibble: 780 × 10\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A4    H7    III         2.6        1.37  20.4  52    253.  408.   620\n 2 A1    H10   I           2.92       1.61  20.3  55.4  283.  441.   641\n 3 A3    H1    I           2          1.05  19.9  53.3  253.  444.   570\n 4 A1    H10   III         2.29       1.15  19.8  55.9  276.  411.   671\n 5 A3    H2    II          2.08       0.93  19.6  52.9  220.  384.   574\n 6 A3    H9    III         2.07       1     19.6  48.2  190.  307.   617\n 7 A4    H8    III         2.6        1.5   19.5  56.1  264.  402.   657\n 8 A2    H6    III         3.18       1.62  19.2  53.0  270.  382.   708\n 9 A4    H7    III         2.76       1.54  19.2  54.1  254.  417.   610\n10 A1    H9    I           2.69       1.8   19    52.4  226.  428.   529\n# ℹ 770 more rows\n\n\nAo combinar a função group_by() com arrange() é possível realizar o ordenamento para cada nível de um determinado fator. No exemplo abaixo, a variável APLA é ordenada de maneira crescente para cada híbrido.\n\nmaize %&gt;%\n  group_by(HIB) %&gt;%\n  arrange(MGRA, .by_group = TRUE)\n\n# A tibble: 780 × 10\n# Groups:   HIB [13]\n   AMB   HIB   REP   APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 A1    H1    II          3.15       1.78  10.9  NA    75.2  256.   294\n 2 A3    H1    III         2.45       1.29   9    51.0  78.9  503.   157\n 3 A3    H1    I           2.13       1.05  11.6  47.0  89.5  300.   298\n 4 A3    H1    II          2.18       1.04  13    46.6 103.   351.   293\n 5 A3    H1    II          2.08       0.94  12    47.6 103.   334.   309\n 6 A3    H1    I           2.07       1.05  13.2  47.9 110.   293.   377\n 7 A3    H1    II          1.93       0.93  13    50.0 120.   276.   433\n 8 A2    H1    III         3.11       1.9   13    50.8 131.   402.   325\n 9 A4    H1    I           2.3        1.25  13.1  50.0 140.   230.   609\n10 A3    H1    II          2.39       1.21  14    50.2 144.   331.   435\n# ℹ 770 more rows"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html",
    "href": "RGV410046_02_PROGRAMACAO.html",
    "title": "2. Introdução à programação R",
    "section": "",
    "text": "Neste material, serão vistos conceitos importantes envolvidos na programação R que envolvem o conhecimento dos tipos de objetos, estruturas de dados e lógica de programação."
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#estuturas-de-dados",
    "href": "RGV410046_02_PROGRAMACAO.html#estuturas-de-dados",
    "title": "2. Introdução à programação R",
    "section": "\n1.1 Estuturas de dados",
    "text": "1.1 Estuturas de dados\nExistem quatro tipos principais de estruturas de dados, que podem ser interpretadas como: logical, integer, double e character (que contém cadeias de caracteres). Vetores do tipo integer e double são conhecidos como vetores numéricos. Cada um dos quatro tipos primários possui uma sintaxe especial para criar um valor individual, um escalar. A função c() combina valores que formam vetores1. Abaixo, é demonstrado como vetores podem ser criados utilizando c(). Note que o código é dado entre parênteses (...) para que o valor seja armazenado no ambiente ao mesmo tempo em que é impresso no console.\n\n1.1.1 Vetores do tipo double\n\nVetores do tipo double podem ser especificadas em formato decimal (0.1234) ou científico (1.23e4).\n\n(x1 &lt;- 1) # Escalar \n\n[1] 1\n\n(x2 &lt;- c(1, 2, 3.5)) # Vetor\n\n[1] 1.0 2.0 3.5\n\ntypeof(x2)\n\n[1] \"double\"\n\n\n\n1.1.2 Vetores do tipo integer\n\nVetores do tipo integer são escritos de forma semelhante aos double, mas devem ser seguidos por L (1234L, 1e4L ou 0xcafeL) e não podem conter valores fracionados.\n\n(x3 &lt;- c(1L,2L,3L)) # Vetor\n\n[1] 1 2 3\n\ntypeof(x3)\n\n[1] \"integer\"\n\n\n\n1.1.3 Vetores do tipo character\n\nVetores do tipo character são cercadas por ” e contém texto, tais como (\"dia\") ou ’ ('noite').\n\n(x4 &lt;- c(\"um\",\"dois\",\"três\")) # Vetor com caracteres\n\n[1] \"um\"   \"dois\" \"três\"\n\ntypeof(x4)\n\n[1] \"character\"\n\n\n\n1.1.4 Vetores do tipo logical\n\nVetores do tipo logical podem ser escritos por extenso (TRUE ou FASLSE) ou abreviados (T ou F).\n\n(x5 &lt;- c(TRUE, FALSE)) # Vetor logical\n\n[1]  TRUE FALSE\n\ntypeof(x5)\n\n[1] \"logical\"\n\n\n\n1.1.5 \nOs vetores foram armazenados em x1, x2, x3 e x4 e ficaram armazenados como valores na área de trabalho como valores (values). Para que os valores sejam mostrados basta digitar no console onde os vetores foram armazenados. Vetores também podem ser criados utilizando as funções rep() e seq(), conforme mostrado abaixo.\n\n(x6 &lt;- rep(5, 10))\n\n [1] 5 5 5 5 5 5 5 5 5 5\n\n(x7 &lt;- seq(1, 5))\n\n[1] 1 2 3 4 5\n\n(x8 &lt;- seq(1, 5, by = 0.5))\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\n(x9 &lt;- seq(2, 20, by = 2))\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\nAgora, objserve o seu ambiente de trabalho. Lá você pode ver os objetos que foram criados.\n\nVocÇe também pode ser combinar as funções c(), rep() e seq() para criar vetores mais complexos, como mostrado abaixo.\n\nrep(c(1, 3, 6), each = 4)     # repete números de uma sequência\n\n [1] 1 1 1 1 3 3 3 3 6 6 6 6\n\nseq(1:5)                      # cria uma sequência\n\n[1] 1 2 3 4 5\n\nrep(seq(1:5), length.out= 15) # define o tamanho da saída\n\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n\n\nUtilizando colchtes [] é possível selecionar um (ou um conjunto) de elementos de um vetor. Por exemplo:\n\nx8[1]            # Seleciona o primeiro elemento do vetor \n\n[1] 1\n\nx8[4]            #  Seleciona o quarto elemento do vetor \n\n[1] 2.5\n\nx8[c(1, 4, 8)]   # Seleciona o primeiro, o quarto e o oitavo elemento\n\n[1] 1.0 2.5 4.5\n\nx8[1:4]          # armazena uma sequência de elementos (primeiro ao quarto)\n\n[1] 1.0 1.5 2.0 2.5\n\n\nEm adição ao uso de [], as funções first(), last() e nth() do pacote dplyr são utilizadas para selecionar o primeiro, o último e o i-ésimo elemento de um vetor. A principal vantagem é que você pode fornecer um vetor secundário opcional que define a ordem e fornecer um valor padrão a ser usado quando a entrada for menor que o esperado.\n\nx &lt;- runif(100, 0, 100)\nlibrary(tidyverse)\nfirst(x)\n\n[1] 65.22831\n\nlast(x)\n\n[1] 32.74952\n\nnth(x, 23)\n\n[1] 19.77796\n\n\n\n\n\n\n\n\nUsamos &lt;- ou = para associação de nomes a objetos?\n\n\n\nMuitos usuários utilizam o símbolo da igualdade “=” para associarmos nomes aos objetos, algo que o ambiente R compreenderá. Contudo, o uso da igualdade deverá em R ser usado apenas para a utilização em argumentos de uma função e não para associação de nomes a objetos. Para mais detalhes, execute o comando ?assignOps."
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#matrizes",
    "href": "RGV410046_02_PROGRAMACAO.html#matrizes",
    "title": "2. Introdução à programação R",
    "section": "\n1.2 Matrizes",
    "text": "1.2 Matrizes\nAs matrizes são um conjunto de valores (ou variáveis) dispostos em linhas e colunas, e que formam um corpo delimitado por [ ]. As matrizes são geralmente representadas genericamente por \\({{\\boldsymbol{A}}_{{\\boldsymbol{MxN}}}}\\), onde M e N represetam os números de linhas e colunas da matriz, respectivamente. As matrizes podem ser facilmente construídas utilizando a função matrix(). Alternativamente, as funções cbind() e rbind() também podem ser utilizadas. A primeira função adiciona colunas as matrizes, enquanto que a segunda adiciona linhas. Veremos mais tarde que estas funções podem ser combinadas com outras funções para construção de dataframes.\n\n## Usando cbind()\ncbind(c(1,2,3,4,5))                # Uma coluna com 5 elementos cada \n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n[5,]    5\n\ncbind(c(1,2,3,4,5),c(6,7,8,9,10))  # 2 colunas de 5 elementos\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n\n\n\n## Usando rbind()\nrbind(c(1,2,3,4,5)) # 1 linha com 5 elementos cada\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n\nrbind(c(1,2,3,4,5),c(6,7,8,9,10)) # 2 linhas com 5 elementos cada\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n\n\nCom a função matrix() podemos podemos criar matrizes. Para isso, alguns argumentos devem ser declarados. Na função matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,dimnames = NULL), os argumentos que devemos inicialmente conhecer são o nrow, ncol e byrow. O primeiro indica o número de linhas da matriz, o segundo a número de colunas e o terceiro indica como a matriz é preenchida. Por default, byrow é FALSE, indicando que as matrizes são preenchidas por colunas. Se TRUE, o preenchimento ocorre por linhas.\n\n## Usando matrix\n(x9 &lt;- matrix(1:15, nrow = 5, ncol = 3))\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nclass(x9)\n\n[1] \"matrix\" \"array\" \n\ntypeof(x9)\n\n[1] \"integer\"\n\n(x10 &lt;- matrix(1:15, nrow = 5, ncol = 3, byrow = TRUE))\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n[5,]   13   14   15\n\n\nPara selecionar elementos, linhas e colunas da matriz com [ ] utiliza-se um sistema de coordenadas:\n\nx9[2, 3] # seleciona o elemento que está na linha 2 e coluna 3\n\n[1] 12\n\nx9[, 2] # \",\" indica que todas as linhas serão selecionadas na coluna 2\n\n[1]  6  7  8  9 10\n\nx9[1, ] # \",\" indica que todas as colunas serão selecionadas na linha 1\n\n[1]  1  6 11\n\n\n\n\n\n\n\n\nTip\n\n\n\nNote que matrizes ficam armazenadas no ambiente glogal em “Data”, não “Values”."
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#data-frame",
    "href": "RGV410046_02_PROGRAMACAO.html#data-frame",
    "title": "2. Introdução à programação R",
    "section": "\n1.3 Data Frame",
    "text": "1.3 Data Frame\nA função data.frame() cria estruturas cujas colunas podem ser valores numéricos ou caracteres. É uma estrutura muito utilizada em funções do software R.\n\nx10 &lt;- data.frame(arvore = paste0(\"O\", 1:5),\n                  altura = c(4, 4.6, 3.8, 5, 4.1))\nclass(x10)\n\n[1] \"data.frame\"\n\nprint(x10)\n\n  arvore altura\n1     O1    4.0\n2     O2    4.6\n3     O3    3.8\n4     O4    5.0\n5     O5    4.1\n\n# o mesmo sistema de coordenadas pode ser utilizado com data.frames\nx10[1, ]\n\n  arvore altura\n1     O1      4"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#tibbles",
    "href": "RGV410046_02_PROGRAMACAO.html#tibbles",
    "title": "2. Introdução à programação R",
    "section": "\n1.4 Tibbles",
    "text": "1.4 Tibbles\nUm tibble ou tbl_df, é uma versão moderna do data.frame. Tibbles são datas frames que não alteram nomes ou tipos de variáveis, possuindo um método print() aprimorado, que facilita o uso com grandes conjuntos de dados contendo objetos complexos. Você pode forçar um objeto de classe data.frame a um de classe tibble utilizando as_tibble() ou criar um a partir de vetores individuais com tibble(). A função tibble(), diferente de data.frame() permite que você se refira às variáveis que você acabou de criar. É possível, também, que um tibble tenha nomes de colunas que não sejam nomes de variáveis R válidos. Por exemplo, elas podem não começar com uma letra ou podem conter caracteres incomuns como um espaço. Para se referir a essas variáveis, você precisa cercá-las com ` `. Neste documento, a estrutura de dados padrão a ser utilizada será tibble.\n\n# Convertendo um dataframe a um tibble\ntbl_x10 &lt;- as_tibble(x10)\nclass(tbl_x10)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nprint(tbl_x10)\n\n# A tibble: 5 × 2\n  arvore altura\n  &lt;chr&gt;   &lt;dbl&gt;\n1 O1        4  \n2 O2        4.6\n3 O3        3.8\n4 O4        5  \n5 O5        4.1\n\n\n\n# Tentando criar um dataframe\ndata.frame(x = 1:5,\n           y = 2:6,\n           z = x ^ 2 + y)\n\n\n# Criando um tibble\ntib1 &lt;- \n  tibble(x = 1:5,\n         y = 2:6,\n         z = x ^ 2 + y)\n\ntib1[, 1]\n\n# A tibble: 5 × 1\n      x\n  &lt;int&gt;\n1     1\n2     2\n3     3\n4     4\n5     5"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#lista",
    "href": "RGV410046_02_PROGRAMACAO.html#lista",
    "title": "2. Introdução à programação R",
    "section": "\n1.5 Lista",
    "text": "1.5 Lista\nNo exemplo abaixo, será armazenado em uma lista um objeto de cada class. Posteriomente, será selecionado o terceiro objeto\n\nlist1 &lt;- list(x2, x9, x10)\nlist1[[3]]\n\n  arvore altura\n1     O1    4.0\n2     O2    4.6\n3     O3    3.8\n4     O4    5.0\n5     O5    4.1"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#funções",
    "href": "RGV410046_02_PROGRAMACAO.html#funções",
    "title": "2. Introdução à programação R",
    "section": "\n2.1 Funções",
    "text": "2.1 Funções\nUma das melhores maneiras de tornar o código mais eficiente é escrever funções. As funções são a base da linguagem R. Através de argumentos que são indicados em funtion(), uma expressão (ou série de expressões) é resolvida e um valor (ou um conjunto de valores) é retornado. As funções permitem automatizar tarefas comuns de uma maneira mais poderosa e geral do que ‘copiar e colar’. Escrever uma função tem três grandes vantagens sobre o uso de copiar e colar:\n\nVocê pode dar a uma função um nome evocativo que torne seu código mais fácil de entender.\nÀ medida que os requisitos mudam, você só precisa atualizar o código em um local, em vez de vários.\nVocê elimina a chance de cometer erros acidentais ao copiar e colar (ex., atualizar um nome de variável em um local, mas não em outro).\n\nConsidere escrever uma função sempre que ‘copiar e colar’ um bloco de código mais de duas vezes. Quando uma função é armazenada no ambiente de trabalho, basta digitar o nome como o qual aquela função foi gravada. Os argumentos podem ser inseridos na ordem em que aparecem na função, sem especificar a qual argumento aquele valor pertence. No caso em que a inserção dos argumentos é diferente da ordem em que aparecem na função, é preciso identificar a qual argumento aquele valor pertente. Note que é possível combinar valores numéricos e texto como argumentos e/ou resultados de funções. Veja alguns exemplos.\n\n# EXEMPLO 1:\n# resolve a função 2x+1\n\nfun1 &lt;- function(x){  # x é o único argumento da função\n  a &lt;- 2 * x + 1\n  return(a) # retorna a\n}\nfun1(2)\n\n[1] 5\n\nfun1(x = 2) # explicita o ragumento\n\n[1] 5\n\n# EXEMPLO 2\n# função para elevar ao quadrado ou cubo\n# inclui condicionantes\nelevar &lt;- function(x, eleva = \"quadrado\"){\n  if(!eleva %in% c(\"quadrado\", \"cubo\")){\n    stop(\"O argumento eleva = \",eleva, \" deve ser ou 'quadrado' ou 'cubo'\")\n  }\n  if(eleva == \"quadrado\"){\n    valor &lt;- ifelse(x^2 &gt;= 1000,\n                    paste(\"O resultado (\",x^2,\") tem mais que 3 dígitos\"),\n                    paste(\"O resultado (\",x^2,\") tem menos que 3 dígitos\"))\n  }\n  if(eleva == \"cubo\"){\n    valor &lt;- ifelse(x^3 &gt;= 1000,\n                    paste(\"O resultado (\",x^3,\") tem mais que 3 dígitos\"),\n                    paste(\"O resultado (\",x^3,\") tem menos que 3 dígitos\"))\n  }\n  \n  return(valor)\n}\n\nelevar(2)                       # usa o valor dos argumentos \n\n[1] \"O resultado ( 4 ) tem menos que 3 dígitos\"\n\nelevar(3, \"cubo\")               # argumentos na sequência que eles aparecem\n\n[1] \"O resultado ( 27 ) tem menos que 3 dígitos\"\n\nelevar(eleva = \"cubo\", x = 15)  # mudar a ordem dos argumentos\n\n[1] \"O resultado ( 3375 ) tem mais que 3 dígitos\"\n\n# EXEMPLO 3: fórmula de Bháskara\n# Encontrar as raízes de uma equação de segundo grau\n# Plotar a curva\nbhaskara &lt;- function(a, b, c, plot = TRUE){ \n  # argumentos a, b e c são \n  dentro_raiz &lt;- b^2 - 4 * a * c\n  if(dentro_raiz &lt; 0){\n    stop(\"Sem solução real\")\n  }\n  delta &lt;- sqrt(dentro_raiz)\n  x1 &lt;- (-b + delta) / (2 * a)\n  x2 &lt;- (-b - delta) / (2 * a)\n  minx &lt;- min(x1, x2)\n  min_exp &lt;- ifelse(minx &lt; 0, minx + minx * 0.2, minx - minx * 0.2)\n  maxx &lt;- max(x1, x2)\n  \n  # checa se precisa plotar\n  if(isTRUE(plot)){\n    # plot.new()\n    # curva\n    curve(a * x^2 + b * x + c, \n          xlim = c(min_exp,\n                   maxx + maxx * 0.2))\n    # pontos nas raízes\n    points(x = c(x1, x2),\n           y = c(0, 0),\n           col = \"black\",\n           pch = 19)\n    # linha no zero\n    abline(h=0, lty=2)\n  }\n  \n  # calcula o x e y do vértice\n  x_vert &lt;- round(-b / (2*a), 3)\n  print(paste0(\"x: \", x_vert))\n  y_vert &lt;- round(a * x_vert^2 + b * x_vert + c , 3)\n  print(paste0(\"y: \", y_vert))\n  \n  # plota os pontos do vértice\n  points(x = x_vert,\n         y = y_vert,\n         col = \"red\",\n         pch = 19)\n  # retorna as raízes\n  print(paste0(\"Raízes: S{\", x1, \";\", x2, \"}\"))\n}\n\nbhaskara(1, -2, -3)\n\n\n\n\n[1] \"x: 1\"\n[1] \"y: -4\"\n[1] \"Raízes: S{3;-1}\"\n\nbhaskara(-1, 4, -3)\n\n\n\n\n[1] \"x: 2\"\n[1] \"y: 1\"\n[1] \"Raízes: S{1;3}\"\n\nbhaskara(1, 2, -8)\n\n\n\n\n[1] \"x: -1\"\n[1] \"y: -9\"\n[1] \"Raízes: S{2;-4}\""
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#operador-pipe",
    "href": "RGV410046_02_PROGRAMACAO.html#operador-pipe",
    "title": "2. Introdução à programação R",
    "section": "\n2.2 Operador pipe",
    "text": "2.2 Operador pipe\nPipes são uma ferramenta poderosa para expressar claramente uma sequência de várias operações. Em resumo, o operador pipe fornece o resultado do lado esquerdo (LHS) do operador como o primeiro argumento do lado direito (RHS). O pipe %&gt;% vem do pacote magrittr e faz parte da família de pacotes tidyverse, que serão explorados no decorrer deste material. O objetivo do pipe é ajudá-lo a escrever código de uma maneira que seja mais fácil de ler e entender. A partir da versão 4.1.0, o R contém um pipe nativo |&gt;. Sutis diferenças são observadas, mas não é nosso objetivo aqui entrar neste universo. Para maiores detalhes veja o vídeo abaixo.\n\nVocê consegue habilitar o pipe nativo no Rstudio, indo em Tools &gt; Global Options &gt; Code e selecionar a caixa indicada abaixo.\n\nPara ver por que o pipe é tão útil, vamos explorar algumas maneiras de escrever o mesmo código. Para isso, considere as seguintes (e simples) operações.\n\n\nCrie uma função que computa o quadrado do desvio de cada termo em relação à média.\nCrie um vetor com 10 dados aleatórios de uma distribuição normal com média 10 e desvio padrão 2, utilizando rnorm().\n\nEleve o vetor numérico ao quadrado\nSome os valores\ndivida por n - 1\nArmazene no objeto var_amo\n\n\n\n# função para computar o quadrado dos desvios\nquadrado_desvio &lt;- function(x){\n  (x - mean(x))^2\n}\n\n\nset.seed(1) # garante reprodutibilidade\n(x &lt;- rnorm(n = 10, mean = 10, sd = 2))\n\n [1]  8.747092 10.367287  8.328743 13.190562 10.659016  8.359063 10.974858\n [8] 11.476649 11.151563  9.389223\n\n(quad_desv &lt;- quadrado_desvio(x))\n\n [1] 2.30223930 0.01058452 3.74679043 8.56238918 0.15571704 3.63032940\n [7] 0.50474281 1.46953515 0.78704779 0.76594412\n\n(soma_quad_desv &lt;- sum(quad_desv))\n\n[1] 21.93532\n\n(var_amo &lt;- sum(soma_quad_desv) / 9)\n\n[1] 2.437258\n\n\nNote que a mesma operação pode ser realizada se você aninhar as funções.\n\n(var_amo &lt;- sum(sum(quadrado_desvio(x))) / 9)\n\n[1] 2.437258\n\n\nAgora, utilizando o pipe, note como o código fica muito mais claro, pois as indicações são feitas na ordem em que elas precisam ser executadas.\n\nvar_amo &lt;- \n  x |&gt; \n  quadrado_desvio() |&gt; \n  sum() / 9\nvar_amo\n\n[1] 2.437258\n\n\n\n\n\n\n\n\nTip\n\n\n\nSe você ainda não percebeu, acabamos de reproduzir o que a função nativa do R var() faz para computar a variância amostral.\n\nvar(x)\n\n[1] 2.437258"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#loops",
    "href": "RGV410046_02_PROGRAMACAO.html#loops",
    "title": "2. Introdução à programação R",
    "section": "\n3.1 Loops",
    "text": "3.1 Loops\nReescrever um código muitas vezes por necessidade de repetir um determinado procedimento seria bastante trabalhoso, além de precisarmos de mais tempo para isso e estarmos mais propensos à erros, como por exemplo, esquecer de trocar o nome de uma variável, ou um coeficiente. Por isso, o R tem algumas funções que fazem essas repetições para nós. Isso é muito comum e pode ser facilmente implementado pela função for(), while() e repeat().\n\n3.1.1 for()\nA função for() repete o código indicado dentro de {} n vezes, sendo n o comprimento da sequência dentro dos parênteses.\n\nj &lt;- 5\nfor (i in 1:j){\n  k &lt;- i * 2\n  print(k)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\n\n\n3.1.2 while()\nA função while() (que significa enquanto) repete o código dentro de {} enquanto alguma condição for verdadeira. Isso é útil, por exemplo, para ser aplicada em um modelo que contém um algoritmo iterativo que necessita de convergência. O modo é iterado infinitas vezes até a convergência ser atingida, ou até uma condição (por exemplo, após um número máximo de iterações) ser atingida.\n\ni &lt;- 1\nwhile (i &lt;= 5){\n  print(i * 2)\n  i &lt;- i + 1\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\n\nNote que os dois últimos exemplos apresentam o mesmo resultado: o R vai retornar uma sequência i sendo i = 1:5, onde cada número será o resultado da multiplicação \\(i \\times 2\\). No caso while(), precisamos mudar o valor de i para que a sequência continue até que a condição (i &lt;= 5) for verdadeira. Em adição, precisamos declarar a variável (i = 1) antes para que o R possa testar a condição expressa dentro dos parênteses. No caso do for(), a sequência progride sem precisarmos fazer isso manualmente.\n\n3.1.3 repeat()\nNo último exemplo, utilizando repeat(), o R repetirá o código dentro de {} sem condições. Com isso, precisamos utilizar a combinação das funções if() e break() para informar ao programa quando o código deve parar de ser repetido.\n\ni &lt;- 1\nrepeat {\n  print(i * 2)\n  i &lt;- i + 1\n  if(i &gt; 5){\n    break()\n  }\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\n\n\n3.1.4 \nImprimir números no console foi uma boa maneira de conhecermos como o procedimento for-loop funciona no R. Em resumo: podemos chegar no mesmo resultado utilziando três abordagens distintas. Mas vamos dar um pouco mais de aplicabilidade aos procedimentos for-loop. Imagine que temos este simples data.frame:\n\ndf &lt;- data.frame(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10),\n  e = rnorm(10)\n)\ndf\n\n             a           b           c          d          e\n1   1.51178117  0.91897737  1.35867955 -0.1645236  0.3981059\n2   0.38984324  0.78213630 -0.10278773 -0.2533617 -0.6120264\n3  -0.62124058  0.07456498  0.38767161  0.6969634  0.3411197\n4  -2.21469989 -1.98935170 -0.05380504  0.5566632 -1.1293631\n5   1.12493092  0.61982575 -1.37705956 -0.6887557  1.4330237\n6  -0.04493361 -0.05612874 -0.41499456 -0.7074952  1.9803999\n7  -0.01619026 -0.15579551 -0.39428995  0.3645820 -0.3672215\n8   0.94383621 -1.47075238 -0.05931340  0.7685329 -1.0441346\n9   0.82122120 -0.47815006  1.10002537 -0.1123462  0.5697196\n10  0.59390132  0.41794156  0.76317575  0.8811077 -0.1350546\n\n\nAgora, imagine que você quer computar a média de cada variável. Você poderia fazer isso copiando e colando 5 vezes o código.\n\nmean(df$a)\n\n[1] 0.248845\n\nmean(df$b)\n\n[1] -0.1336732\n\nmean(df$c)\n\n[1] 0.1207302\n\nmean(df$d)\n\n[1] 0.1341367\n\nmean(df$e)\n\n[1] 0.1434569\n\n\nUsando o for loop, teríamos um vetor de médias, com o seguinte código\n\noutput &lt;- NULL                 # 1. output\nfor (i in 1:ncol(df)) {        # 2. Sequência\n  output[i] &lt;- mean(df[[i]])   # 3. o que é executado dentro de cada loop\n}\noutput\n\n[1]  0.2488450 -0.1336732  0.1207302  0.1341367  0.1434569\n\n\nBem, neste exemplo, as duas abordagens têm 5 linhas de programação e realmente parece que o loop foi um tanto quanto mais “difícil” de implementar. Sua vantagem, no entanto, aparece quando muitas colunas estão disponíveis. Neste caso, se um conjunto de dados com 100 variáveis precisa ser analizado, as mesmas cinco linhas de programação são utilizadas."
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#família-apply",
    "href": "RGV410046_02_PROGRAMACAO.html#família-apply",
    "title": "2. Introdução à programação R",
    "section": "\n3.2 Família apply\n",
    "text": "3.2 Família apply\n\nNativamente, o R contém uma família de funções vetorizadas que minimizam sua necessidade de criar loops explicitamente. Essas funções aplicarão uma função especificada a um objeto de dados e sua principal diferença está na classe de objeto na qual a função é aplicada (lista vs. matriz, etc.) e na classe de objeto que será retornada da função.\n\n3.2.1 apply()\n\nA função apply() é mais frequentemente usada para aplicar uma função às linhas ou colunas (margens) de matrizes ou data.frames. Note como montante de código para computar a média de cada coluna de df é drasticamente reduzido utilizando apply().\n\napply(df, 1, mean) # média das linhas\n\n [1]  0.80460408  0.04076075  0.17581582 -0.96611130  0.22239302  0.15136957\n [7] -0.11378305 -0.17236625  0.38009399  0.50421435\n\napply(df, 2, mean) # média das colunas\n\n         a          b          c          d          e \n 0.2488450 -0.1336732  0.1207302  0.1341367  0.1434569 \n\n\n\n3.2.2 lapply()\n\nA função lapply() faz a seguinte série simples de operações:\n\nFaz um loop em uma lista, iterando sobre cada elemento dessa lista;\nAplica uma função a cada elemento da lista (uma função que você especifica)\nRetorna uma lista (o l é para “lista”).\n\n\nlapply(df, mean)\n\n$a\n[1] 0.248845\n\n$b\n[1] -0.1336732\n\n$c\n[1] 0.1207302\n\n$d\n[1] 0.1341367\n\n$e\n[1] 0.1434569\n\n\n\n3.2.3 sapply()\n\nA função sapply() se comporta de maneira semelhante a lapply(); a única diferença está no valor retornado. sapply() tentará simplificar o resultado, se possível.\n\nsapply(df, mean)\n\n         a          b          c          d          e \n 0.2488450 -0.1336732  0.1207302  0.1341367  0.1434569"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#família-map_",
    "href": "RGV410046_02_PROGRAMACAO.html#família-map_",
    "title": "2. Introdução à programação R",
    "section": "\n3.3 Família map_*()\n",
    "text": "3.3 Família map_*()\n\nO padrão de fazer um loop sobre um vetor, fazer algo em cada elemento e salvar os resultados é tão comum que o pacote purrr fornece uma família de funções para fazer isso por você. Existe uma função para cada tipo de saída:\n\n\nmap() retorna uma lista.\n\nmap_lgl() retorna um vetor lógico.\n\nmap_int() retorna um vetor de números inteiros.\n\nmap_dbl() retorna um vetor double.\n\nmap_chr() retorna um vetor de caracteres.\n\n\nlibrary(purrr)\n\nmap(df, mean) # retorna uma lista\n\n$a\n[1] 0.248845\n\n$b\n[1] -0.1336732\n\n$c\n[1] 0.1207302\n\n$d\n[1] 0.1341367\n\n$e\n[1] 0.1434569\n\nmap_dbl(df, mean) # retorna um vetor double\n\n         a          b          c          d          e \n 0.2488450 -0.1336732  0.1207302  0.1341367  0.1434569"
  },
  {
    "objectID": "RGV410046_02_PROGRAMACAO.html#footnotes",
    "href": "RGV410046_02_PROGRAMACAO.html#footnotes",
    "title": "2. Introdução à programação R",
    "section": "Footnotes",
    "text": "Footnotes\n\nVetores são uma estrutura de dados básica do R que permite armazenar um conjunto de valores numéricos ou de caracteres em um objeto nomeado↩︎\nO teorema central do limite define que distribuição das médias amostrais é aproximadamente normal, a medida em que o número de amostas aumenta, independentemente da forma da distribuição da população.↩︎"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html",
    "href": "RGV410046_00_ABOUT.html",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "",
    "text": "Bem-vindo ao material de apoio da disciplina RGV410046 (Introdução à linguagem R de programação)! Esta página contém os dados e scripts R necessários para aplicação prática dos conteúdos vistos na disciplina."
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section",
    "href": "RGV410046_00_ABOUT.html#section",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.1 30/09/2024",
    "text": "4.1 30/09/2024\n\nIntrodução à disciplina\nInstalação do R e Rstudio\nIntrodução ao R\n\nScript\nPacotes\nFóruns e materiais de apoio\n\n\nApresentação do desafio (avaliação da disciplina)\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-1",
    "href": "RGV410046_00_ABOUT.html#section-1",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.2 02/10/2024",
    "text": "4.2 02/10/2024\n\nDinâmica aula anterior\nTipos de dados\nNumérico\nLógico\nCaractere\nEstrutura de dados;\n\nVetor\nMatriz\nData frame\nTibbles\nArray\n\n\nLógica de programação\n\nBase\nTidyverse\n\n\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-2",
    "href": "RGV410046_00_ABOUT.html#section-2",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.3 03/10/2024",
    "text": "4.3 03/10/2024\n\nImportação de dados (pc, repositório)\ndados tidy\nInspeção de dados\nExportação de dados\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-3",
    "href": "RGV410046_00_ABOUT.html#section-3",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.4 04/10/2024",
    "text": "4.4 04/10/2024\n\nSeleção de dados\nselect\nfilter\nslice\narrange\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-4",
    "href": "RGV410046_00_ABOUT.html#section-4",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.5 07/10/2024",
    "text": "4.5 07/10/2024\n\nManipulação de dados\nLonger (dados errados, para arrumar)\nWider\nSeparate\nUnite\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-5",
    "href": "RGV410046_00_ABOUT.html#section-5",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.6 09/10/2024",
    "text": "4.6 09/10/2024\n\nMutação de dados\nmutate\nacross\ngroup_by\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-6",
    "href": "RGV410046_00_ABOUT.html#section-6",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.7 10/10/2024",
    "text": "4.7 10/10/2024\n\nResumo de dados\nsummarise\nacross\ngroup_by\nAplicação prática"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#section-7",
    "href": "RGV410046_00_ABOUT.html#section-7",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n4.8 11/10/2024",
    "text": "4.8 11/10/2024\n\nEntrega do desafio\nCorreção do desafio"
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#código-fonte",
    "href": "RGV410046_00_ABOUT.html#código-fonte",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n10.1 Código fonte",
    "text": "10.1 Código fonte\nO código fonte deste material pode ser encontrado neste repositório GitHub. Para informar qualquer problema, por favor, crie um pull request."
  },
  {
    "objectID": "RGV410046_00_ABOUT.html#licença",
    "href": "RGV410046_00_ABOUT.html#licença",
    "title": "RGV410046 - Introdução à linguagem R de programação",
    "section": "\n10.2 Licença",
    "text": "10.2 Licença\nEste material é distribuído nos termos da licença CC BY-NC-SA 4.0\nO resumo legível da licença afirma que você tem o direito de:\n\n\nCompartilhar — copiar e redistribuir o material em qualquer suporte ou formato\n\nAdaptar — remixar, transformar, e criar a partir do material\n\nAtribuição — Você deve dar o crédito apropriado, prover um link para a licença e indicar se mudanças foram feitas. Você deve fazê-lo em qualquer circunstância razoável, mas de nenhuma maneira que sugira que o licenciante apoia você ou o seu uso.\n\nDe acordo com os termos seguintes\n\n\nNão Comercial — Você não pode usar o material para fins comerciais.\n\nCompartilhaIgual — Se você remixar, transformar, ou criar a partir do material, tem de distribuir as suas contribuições sob a mesma licença que o original.\n\nSem restrições adicionais — Você não pode aplicar termos jurídicos ou medidas de caráter tecnológico que restrinjam legalmente outros de fazerem algo que a licença permita.\n\n\n\n\nFree website hit counter"
  },
  {
    "objectID": "RGV410046_01_INTRO.html",
    "href": "RGV410046_01_INTRO.html",
    "title": "1. O software R",
    "section": "",
    "text": "O artigo R: A Language for Data Analysis and Graphics1, escrito pelos desenvolvedores da linguagem George Ross Ihaka e Robert Clifford Gentleman, marca o início de uma nova era no processamento e análise de dados: o desenvolvimento do software R.\n\n\nCriadores do 2\n\nO R é uma linguagem e ambiente estatístico que traz muitas vantagens para o usuário, embora elas não sejam tão obvias inicialmente:\n\nO R é um Software Livre (livre no sentido de liberdade) distribuído sob a Licença Pública Geral3, podendo ser livremente copiado, distribuído, e instalado em diversos computadores livremente. Isso contrasta com softwares comerciais, que têm licenças altamente restritivas, que não permitem que cópias sejam distribuídas ou instaladas em mais de um computador sem a devida licença (que obviamente é paga!);\nA grande maioria dos Softwares livres são grátis, e o R não é uma exceção;\nOs códigos-fontes R estão disponíveis para os usuários, e atualmente são gerenciados por um grupo chamado R Development Core Team4. A vantagem de ter o código aberto é que falhas podem ser detectadas e rapidamente corrigidas. Este sistema de revisão depende da participação dos usuários. Em contraste, em muitos pacotes comerciais, as falhas não são corrigidas até o lançamento da próxima versão, o que pode levar vários anos;\nO R fornece um interface de entrada por linha de comando (ELC).\n\nNo software R, todos os comandos são digitados e o mouse é pouco usado. Pode parecer antigo, pouco amigável ou até pobre em recursos visuais, mas isso faz com que nos deparemos com o melhor recurso do R: a sua flexibilidade. Para usuários familiarizados, a linguagem do R se torna clara e simples. Com poucos comandos, funções poderosas podem ser5 e o usuário é sempre consciente do que foi pedido através da ELC (Meus dados, minhas análises!). Isso contrasta com pacotes que possuem uma interface amigável (point-and-click), mas que escondem a dinâmica dos cálculos e, potencialmente, os seus erros. Finalmente, o R fornece uma ampla variedade de procedimentos estatísticos básicos ou que exigem grande esforço computacional (modelagem linear e não linear, testes estatísticos clássicos, análise de séries temporais, classificação, agrupamento, etc.) e recursos gráficos elegantes. Um dos pontos fortes de R é a facilidade com que gráficos de qualidade podem ser produzidos, incluindo símbolos matemáticos e fórmulas, quando necessário. O software R está disponível em uma ampla variedade de plataformas UNIX e sistemas similares (incluindo FreeBSD e Linux), Windows e MacOS."
  },
  {
    "objectID": "RGV410046_01_INTRO.html#meu-primeiro-script",
    "href": "RGV410046_01_INTRO.html#meu-primeiro-script",
    "title": "1. O software R",
    "section": "\n2.1 Meu primeiro script",
    "text": "2.1 Meu primeiro script\nO primero passo é criar um novo script, seguindo os seguintes passos: File &gt; New File &gt; R script ou utilizando o atalho Ctrl+Shift+N. Para salvar um script, devemos clicar no botão com o símbolo de disquete (R/RStudio), escolher o nome do arquivo e o diretório onde o arquivo será armazenado no seu computador. Algumas importantes dicas:\n\nEscolha sempre um nome sem caracteres especiais (ex., ç, ã, é, etc.)\nEscolha sempre um nome curto ou abreviado, que identifique a finalidade das linhas de comando escritas (ex., dftese)\nEvite espaços se o nome do arquivo for composto. Para isso, use um uderscore ‘_’(ex., df_tese)"
  },
  {
    "objectID": "RGV410046_01_INTRO.html#diretório-de-trabalho",
    "href": "RGV410046_01_INTRO.html#diretório-de-trabalho",
    "title": "1. O software R",
    "section": "\n2.2 Diretório de trabalho",
    "text": "2.2 Diretório de trabalho\nAntes de iniciar as análises, recomenda-se escolher um diretório onde devem estar os inputs (dados) e para onde serão enviados os outputs (gráficos, arquivos .txt, .xlsx, etc). Para selecionar o diretório, basta seguir o caminho Session &gt; Set Working Directory &gt; Choosing diretory ou utilizar as teclas de atalho Ctrl+Shift+H.\n\n\nSelecionando um diretório"
  },
  {
    "objectID": "RGV410046_01_INTRO.html#atribuições",
    "href": "RGV410046_01_INTRO.html#atribuições",
    "title": "1. O software R",
    "section": "\n4.1 Atribuições",
    "text": "4.1 Atribuições\nOs comandos elementares podem ser divididos em expressões e atribuições. Por exemplo, podemos estar interessados em resolver a seguinte expressão \\(10+15=25\\).\n\n10 + 15\n\n[1] 25\n\n\nNo console quando passamos pelo comando, o R avalia a função e retorna o resultado. Caso queiramos armazenar este resultado em algum objeto, usamos a atribuição &lt;- (Alt + -) que é utilizada no formato objeto &lt;- operacao. Considerano o mesmo caso anterior, um objeto soma é criado com\n\nsoma &lt;- 10 + 15"
  },
  {
    "objectID": "RGV410046_01_INTRO.html#operadores-matemáticos",
    "href": "RGV410046_01_INTRO.html#operadores-matemáticos",
    "title": "1. O software R",
    "section": "\n4.2 Operadores matemáticos",
    "text": "4.2 Operadores matemáticos\nConhecendo estes comandos elementares, podemos passar para as operações matemáticas mais utilizadas e que são cruciais na linguagem de programação. No R, estas operações são baseadas em símbolos ou funções que se assemelham à maioria dos outros softwares estatísticos.\n\n1 + 1 # Soma\n\n[1] 2\n\n2 - 1 # Subtração\n\n[1] 1\n\n2 * 2 # Multiplicação\n\n[1] 4\n\n1 + 2 * 2 ^ 2 # Eleva ao quadrado, multiplica e soma\n\n[1] 9\n\n((1 + 2) * 2) ^ 2 # Soma, multiplica e eleva ao quadrado\n\n[1] 36\n\nsqrt(4) # Raiz quadrada\n\n[1] 2\n\n4^2 # Potência\n\n[1] 16\n\nlog(10) # Por default, o logarítimo é de base e (logarítimo natural)\n\n[1] 2.302585\n\nlog(100, 10) # Logarítimo de base 10\n\n[1] 2\n\nexp(100) # exponencial\n\n[1] 2.688117e+43"
  },
  {
    "objectID": "RGV410046_01_INTRO.html#álgebra-de-matrizes-avançado",
    "href": "RGV410046_01_INTRO.html#álgebra-de-matrizes-avançado",
    "title": "1. O software R",
    "section": "\n4.3 Álgebra de matrizes (avançado)",
    "text": "4.3 Álgebra de matrizes (avançado)\nPara multiplicação de matrizes utiliza-se %*% ao envéz de *. Note a diferença no exemplo abaixo.\n\n(x &lt;- matrix(1:4, ncol = 2))\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n(y &lt;- matrix(5:8, ncol = 2))\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\nO resultado da multiplicação da matriz x e y é dado por:\n\\[\n    \\left( {\\begin{array}{*{20}{c}}{1 \\cdot 5 + 3 \\cdot 6}&{1 \\cdot 7 + 3 \\cdot 8}\\\\{2 \\cdot 5 + 4 \\cdot 6}&{2 \\cdot 7 + 4 \\cdot 8}\\end{array}} \\right) = \\left( {\\begin{array}{*{20}{c}}{23}&{31}\\\\{34}&{46}\\end{array}} \\right)\n\\]\n\nx * y # Errado\n\n     [,1] [,2]\n[1,]    5   21\n[2,]   12   32\n\nx %*% y # Certo\n\n     [,1] [,2]\n[1,]   23   31\n[2,]   34   46\n\n\nA função t() é utilizada para transposição de matrizes e solve() para inversão de matrizes. Vamos resolver o seguinte sistema de equações utilizando estes operadores.\n\\[\n\\begin{array}{l}{x_1} + 2{x_2} = 4\\\\{x_1} - {x_2} = 1\\end{array}\n\\]\nMatricialmente o sistema acima é dado por:\n\\[\n\\left[ {\\begin{array}{*{20}{c}}{\\begin{array}{*{20}{l}}1\\\\1\\end{array}}&{\\begin{array}{*{20}{c}}2\\\\{ - 1}\\end{array}}\\end{array}} \\right]\\left[ {\\begin{array}{*{20}{c}}{{x_1}}\\\\{{x_2}}\\end{array}} \\right] = \\left[ {\\begin{array}{*{20}{c}}4\\\\1\\end{array}} \\right]\n\\]\nEsse sistema de equações é representado por \\({\\bf{AX}} = {\\bf{c}}\\) e tem como solução \\({\\bf{X = }}{{\\bf{A}}^{{\\bf{ - 1}}}}{\\bf{c}}\\)\n\n(A &lt;- matrix(c(1, 1, 2, -1), ncol = 2))\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    1   -1\n\n# Transposta de A\nt(A)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2   -1\n\n# resolução do sistema de equações\n(Ainv &lt;- solve(A)) # Obtém a inversa generalizada de A\n\n          [,1]       [,2]\n[1,] 0.3333333  0.6666667\n[2,] 0.3333333 -0.3333333\n\n(c &lt;- c(4, 1)) # Vetor C\n\n[1] 4 1\n\n(X &lt;- Ainv %*% c)\n\n     [,1]\n[1,]    2\n[2,]    1\n\n\n\n\n\n\n\n\nTip\n\n\n\nNote que o mesmo resultado anterior pode ser obtido sem a necessidade de atribuição, ao declarar todas as operações em um único comando\n\nsolve(matrix(c(1, 1, 2, -1), ncol = 2)) %*% c(4, 1)\n\n     [,1]\n[1,]    2\n[2,]    1\n\n\n\n\nA função det() é utilizada para calcular o determinante de uma matriz e função eigen() para calcular calcular autovalores e autovetores\n\n(X &lt;- matrix(c(1, 2, 5, 3, 4, 5, 6, 1, 9), ncol = 3))\n\n     [,1] [,2] [,3]\n[1,]    1    3    6\n[2,]    2    4    1\n[3,]    5    5    9\n\n(detX &lt;- det(X))\n\n[1] -68\n\n\n\n(av &lt;- eigen(X))\n\neigen() decomposition\n$values\n[1] 12.980067  2.854933 -1.835000\n\n$vectors\n           [,1]       [,2]       [,3]\n[1,] -0.4785227  0.2342735 -0.9165278\n[2,] -0.2017392 -0.8386325  0.2624173\n[3,] -0.8545861  0.4917432  0.3018507\n\nav$values # Extrai os autovalores\n\n[1] 12.980067  2.854933 -1.835000\n\n\n\nav$vectors # Extrai os autovetores\n\n           [,1]       [,2]       [,3]\n[1,] -0.4785227  0.2342735 -0.9165278\n[2,] -0.2017392 -0.8386325  0.2624173\n[3,] -0.8545861  0.4917432  0.3018507\n\n\nA função diag() extrai a diagonal de uma matriz ou cria uma matriz onde a diagonal são os elementos declarados. Os próximos comandos extraem a diagonal de X e criam uma matriz identidade, com 3 linhas e 3 colunas.\n\ndiag(X)\n\n[1] 1 4 9\n\ndiag(x = 1, nrow = 3, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1"
  },
  {
    "objectID": "RGV410046_01_INTRO.html#footnotes",
    "href": "RGV410046_01_INTRO.html#footnotes",
    "title": "1. O software R",
    "section": "Footnotes",
    "text": "Footnotes\n\nhttps://www.jstor.org/stable/1390807?seq=1#page_scan_tab_contents↩︎\nFonte: Robert Gentleman&lt;https://biocasia2020.bioconductor.org/&gt;; Ross Ihaka: &lt;https://stat.auckland.ac.nz/&gt;↩︎\nhttps://www.gnu.org/licenses/quick-guide-gplv3.html↩︎\nhttps://www.r-project.org/↩︎\nVeja uma breve história de como o pacote metan, desenvolvido pelo prof. Olivoto, foi concebido https://methodsblog.com/2020/05/28/metan_package/↩︎\nhttps://www.rstudio.com/↩︎\nhttps://www.tidyverse.org/↩︎"
  },
  {
    "objectID": "RGV410046_03_DADOS.html",
    "href": "RGV410046_03_DADOS.html",
    "title": "3. Dados",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#do-excel",
    "href": "RGV410046_03_DADOS.html#do-excel",
    "title": "3. Dados",
    "section": "\n4.1 Do excel",
    "text": "4.1 Do excel\n\n4.1.1 Um arquivo\n\n# primeira planilha do excel\ndf_excel &lt;- import(\"df_excel.xlsx\")\ndf_excel\n\n   RAD REP AF_M2       AF      MST\n1   50   1  5.02 5016.429 12.30785\n2   50   2  3.65 3648.359 10.73315\n3   50   3  3.93 3925.333 10.86140\n4   50   4  4.71 4705.269 10.97850\n5   70   1  6.12 6118.425 15.75180\n6   70   2  5.61 5614.233 13.30495\n7   70   3  5.11 5109.944 13.88435\n8   70   4  4.98 4975.857 13.09225\n9  100   1  5.46 5464.528 16.92240\n10 100   2  5.55 5551.951 14.93085\n11 100   3  5.72 5723.849 16.12900\n12 100   4  5.87 5869.697 15.78145\n\n# uma planilha específica\n# converter para tibble\ndf_excel2 &lt;- \n  import(\"df_excel.xlsx\",\n         sheet = \"traits\",\n         setclass = \"tbl\")\ndf_excel2\n\n# A tibble: 12 × 2\n      AF   MST\n   &lt;dbl&gt; &lt;dbl&gt;\n 1 5016.  12.3\n 2 3648.  10.7\n 3 3925.  10.9\n 4 4705.  11.0\n 5 6118.  15.8\n 6 5614.  13.3\n 7 5110.  13.9\n 8 4976.  13.1\n 9 5465.  16.9\n10 5552.  14.9\n11 5724.  16.1\n12 5870.  15.8\n\n\n\n4.1.2 Vários arquivos\n\n(padrao &lt;- list.files(pattern = \"df_excel\"))\n\n[1] \"df_excel.xlsx\"  \"df_excel2.xlsx\" \"df_excel3.xlsx\"\n\ndf_lista &lt;- import_list(file = padrao)\nstr(df_lista)\n\nList of 3\n $ df_excel :'data.frame':  12 obs. of  5 variables:\n  ..$ RAD  : num [1:12] 50 50 50 50 70 70 70 70 100 100 ...\n  ..$ REP  : num [1:12] 1 2 3 4 1 2 3 4 1 2 ...\n  ..$ AF_M2: num [1:12] 5.02 3.65 3.93 4.71 6.12 5.61 5.11 4.98 5.46 5.55 ...\n  ..$ AF   : num [1:12] 5016 3648 3925 4705 6118 ...\n  ..$ MST  : num [1:12] 12.3 10.7 10.9 11 15.8 ...\n  ..- attr(*, \"filename\")= chr \"df_excel.xlsx\"\n $ df_excel2:'data.frame':  12 obs. of  5 variables:\n  ..$ RAD  : num [1:12] 50 50 50 50 70 70 70 70 100 100 ...\n  ..$ REP  : num [1:12] 1 2 3 4 1 2 3 4 1 2 ...\n  ..$ AF_M2: num [1:12] 5.02 3.65 3.93 4.71 6.12 5.61 5.11 4.98 5.46 5.55 ...\n  ..$ AF   : num [1:12] 5016 3648 3925 4705 6118 ...\n  ..$ MST  : num [1:12] 12.3 10.7 10.9 11 15.8 ...\n  ..- attr(*, \"filename\")= chr \"df_excel2.xlsx\"\n $ df_excel3:'data.frame':  12 obs. of  5 variables:\n  ..$ RAD  : num [1:12] 50 50 50 50 70 70 70 70 100 100 ...\n  ..$ REP  : num [1:12] 1 2 3 4 1 2 3 4 1 2 ...\n  ..$ AF_M2: chr [1:12] \"5,02\" \"3,65\" \"3,93\" \"4,71\" ...\n  ..$ AF   : chr [1:12] \"5016,43\" \"3648,36\" \"3925,33\" \"4705,27\" ...\n  ..$ MST  : chr [1:12] \"12,31\" \"10,73\" \"10,86\" \"10,98\" ...\n  ..- attr(*, \"filename\")= chr \"df_excel3.xlsx\"\n\ndf_lista_bind &lt;- import_list(file = padrao, rbind = TRUE)\ndf_lista_bind\n\n   RAD REP AF_M2         AF      MST          _file\n1   50   1  5.02 5016.42875 12.30785  df_excel.xlsx\n2   50   2  3.65  3648.3589 10.73315  df_excel.xlsx\n3   50   3  3.93 3925.33325  10.8614  df_excel.xlsx\n4   50   4  4.71  4705.2685  10.9785  df_excel.xlsx\n5   70   1  6.12  6118.4251  15.7518  df_excel.xlsx\n6   70   2  5.61 5614.23305 13.30495  df_excel.xlsx\n7   70   3  5.11 5109.94435 13.88435  df_excel.xlsx\n8   70   4  4.98 4975.85695 13.09225  df_excel.xlsx\n9  100   1  5.46   5464.528  16.9224  df_excel.xlsx\n10 100   2  5.55 5551.95115 14.93085  df_excel.xlsx\n11 100   3  5.72 5723.84875   16.129  df_excel.xlsx\n12 100   4  5.87 5869.69745 15.78145  df_excel.xlsx\n13  50   1  5.02 5016.42875 12.30785 df_excel2.xlsx\n14  50   2  3.65  3648.3589 10.73315 df_excel2.xlsx\n15  50   3  3.93 3925.33325  10.8614 df_excel2.xlsx\n16  50   4  4.71  4705.2685  10.9785 df_excel2.xlsx\n17  70   1  6.12  6118.4251  15.7518 df_excel2.xlsx\n18  70   2  5.61 5614.23305 13.30495 df_excel2.xlsx\n19  70   3  5.11 5109.94435 13.88435 df_excel2.xlsx\n20  70   4  4.98 4975.85695 13.09225 df_excel2.xlsx\n21 100   1  5.46   5464.528  16.9224 df_excel2.xlsx\n22 100   2  5.55 5551.95115 14.93085 df_excel2.xlsx\n23 100   3  5.72 5723.84875   16.129 df_excel2.xlsx\n24 100   4  5.87 5869.69745 15.78145 df_excel2.xlsx\n25  50   1  5,02    5016,43    12,31 df_excel3.xlsx\n26  50   2  3,65    3648,36    10,73 df_excel3.xlsx\n27  50   3  3,93    3925,33    10,86 df_excel3.xlsx\n28  50   4  4,71    4705,27    10,98 df_excel3.xlsx\n29  70   1  6,12    6118,43    15,75 df_excel3.xlsx\n30  70   2  5,61    5614,23    13,30 df_excel3.xlsx\n31  70   3  5,11    5109,94    13,88 df_excel3.xlsx\n32  70   4  4,98    4975,86    13,09 df_excel3.xlsx\n33 100   1  5,46    5464,53    16,92 df_excel3.xlsx\n34 100   2  5,55    5551,95    14,93 df_excel3.xlsx\n35 100   3  5,72    5723,85    16,13 df_excel3.xlsx\n36 100   4  5,87    5869,70    15,78 df_excel3.xlsx"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#planilha-separada-por-vírgulas",
    "href": "RGV410046_03_DADOS.html#planilha-separada-por-vírgulas",
    "title": "3. Dados",
    "section": "\n4.2 Planilha separada por vírgulas",
    "text": "4.2 Planilha separada por vírgulas\n\ndf_csv &lt;- import(\"df_csv.csv\")\ndf_csv\n\n   RAD REP AF_M2      AF   MST\n1   50   1  5.02 5016.43 12.31\n2   50   2  3.65 3648.36 10.73\n3   50   3  3.93 3925.33 10.86\n4   50   4  4.71 4705.27 10.98\n5   70   1  6.12 6118.43 15.75\n6   70   2  5.61 5614.23 13.30\n7   70   3  5.11 5109.94 13.88\n8   70   4  4.98 4975.86 13.09\n9  100   1  5.46 5464.53 16.92\n10 100   2  5.55 5551.95 14.93\n11 100   3  5.72 5723.85 16.13\n12 100   4  5.87 5869.70 15.78"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#arquivos-de-texto",
    "href": "RGV410046_03_DADOS.html#arquivos-de-texto",
    "title": "3. Dados",
    "section": "\n4.3 Arquivos de texto",
    "text": "4.3 Arquivos de texto\n\ndf_txt &lt;- import(\"df_txt.txt\")\ndf_txt\n\n   RAD REP AF_M2      AF   MST\n1   50   1  5.02 5016.43 12.31\n2   50   2  3.65 3648.36 10.73\n3   50   3  3.93 3925.33 10.86\n4   50   4  4.71 4705.27 10.98\n5   70   1  6.12 6118.43 15.75\n6   70   2  5.61 5614.23 13.30\n7   70   3  5.11 5109.94 13.88\n8   70   4  4.98 4975.86 13.09\n9  100   1  5.46 5464.53 16.92\n10 100   2  5.55 5551.95 14.93\n11 100   3  5.72 5723.85 16.13\n12 100   4  5.87 5869.70 15.78"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#google-sheets",
    "href": "RGV410046_03_DADOS.html#google-sheets",
    "title": "3. Dados",
    "section": "\n4.4 Google sheets",
    "text": "4.4 Google sheets\n\nurl &lt;- \"https://docs.google.com/spreadsheets/d/1b-Sj9l-VwJ-Oy-hFx7j8twsA5oC6-Fr9ukllywfim0E\"\ndf_gsheet &lt;- import(url, dec = \",\")\ndf_gsheet\n\n             RAD,REP,AF_M2,AF,MST\n1   50,1,\"5,02\",\"5016,43\",\"12,31\"\n2   50,2,\"3,65\",\"3648,36\",\"10,73\"\n3   50,3,\"3,93\",\"3925,33\",\"10,86\"\n4   50,4,\"4,71\",\"4705,27\",\"10,98\"\n5   70,1,\"6,12\",\"6118,43\",\"15,75\"\n6    70,2,\"5,61\",\"5614,23\",\"13,3\"\n7   70,3,\"5,11\",\"5109,94\",\"13,88\"\n8   70,4,\"4,98\",\"4975,86\",\"13,09\"\n9  100,1,\"5,46\",\"5464,53\",\"16,92\"\n10 100,2,\"5,55\",\"5551,95\",\"14,93\"\n11 100,3,\"5,72\",\"5723,85\",\"16,13\"\n12  100,4,\"5,87\",\"5869,7\",\"15,78\""
  },
  {
    "objectID": "RGV410046_03_DADOS.html#spss",
    "href": "RGV410046_03_DADOS.html#spss",
    "title": "3. Dados",
    "section": "\n5.1 SPSS",
    "text": "5.1 SPSS\nO arquivo \".sav\" de exemplo foi baixado deste site\n\ndf_spss &lt;- import(\"df_spss.sav\", setclass = \"tbl\")\ndf_spss\n\n# A tibble: 306 × 59\n   IDnumber   age   sex workstat increg incmnth incwk housing living homepay\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;\n 1 20160186    19     2        3      1       0   0         2      1       1\n 2 20160011    17     2        0      0       0   0         2      1       1\n 3 20160081    18     2        3      1     300  69.2       2      1       1\n 4 20160155    18     2        0      0       0   0         2      1       1\n 5 20160182    19     2        0      1     600 138.        2      1       4\n 6 20160027    17     2        0      0       0   0         2      1       4\n 7 20160188    19     2        0      0       0   0         2      1      99\n 8 20160013    17     2        0      0       0   0         2      1       1\n 9 20160214    20     2        0      1    1500 346.        3      2       4\n10 20160216    20     2        3      1     400  92.3       3      2       1\n# ℹ 296 more rows\n# ℹ 49 more variables: homecost &lt;dbl&gt;, homecostwk &lt;dbl&gt;, mobile &lt;dbl&gt;,\n#   mobilepay &lt;dbl&gt;, mobilecost &lt;dbl&gt;, mobilecostwk &lt;dbl&gt;, transport &lt;dbl&gt;,\n#   food &lt;dbl&gt;, entertain &lt;dbl&gt;, privhlth &lt;dbl&gt;, fs_illness &lt;dbl&gt;,\n#   fs_accident &lt;dbl&gt;, fs_death &lt;dbl&gt;, fs_mtlillness &lt;dbl&gt;,\n#   fs_disability &lt;dbl&gt;, fs_divsep &lt;dbl&gt;, fs_nogetjob &lt;dbl&gt;,\n#   fs_lossofjob &lt;dbl&gt;, fs_alcdrug &lt;dbl&gt;, fs_witviol &lt;dbl&gt;, …"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#dbf",
    "href": "RGV410046_03_DADOS.html#dbf",
    "title": "3. Dados",
    "section": "\n5.2 DBF",
    "text": "5.2 DBF\nO arquivo \".dbf\" de exemplo foi baixado deste site\n\ndf_dbf &lt;- import(\"df_dbf.dbf\", setclass = \"tbl\")\ndf_dbf\n\n# A tibble: 67 × 15\n      ID CATCOUNT AGRPCOUNT PGRPCOUNT ORDER CODE     NAME  THUMBNAIL IMAGE PRICE\n   &lt;int&gt;    &lt;int&gt;     &lt;int&gt;     &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt;\n 1    87        2         0         0    87 1        Asso… graphics… grap…   0  \n 2    26        3         0         0    26 CPKG     Chri… graphics… grap…   0  \n 3    27        3         0         0    27 CHOC     Choc… graphics… grap…   0  \n 4    28        3         0         0    28 PASTEL   Past… graphics… grap…   0  \n 5    29        2         0         0    29 CKR-1001 Chec… graphics… grap…  15.8\n 6    30        3         0         0    30 C        Chri… graphics… grap…   0  \n 7    31        3         0         0    31 TBC01    Truf… graphics… grap…  19.2\n 8    32        2         0         0    32 BD01     Bisc… graphics… grap…  28.8\n 9    33        1         0         0    33 DS02     Dres… graphics… grap…  24.0\n10    34        1         0         0    34 AB01     Apri… graphics… grap…  38.0\n# ℹ 57 more rows\n# ℹ 5 more variables: COST &lt;dbl&gt;, DESC &lt;chr&gt;, WEIGHT &lt;dbl&gt;, TAXABLE &lt;lgl&gt;,\n#   ACTIVE &lt;lgl&gt;"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#ods",
    "href": "RGV410046_03_DADOS.html#ods",
    "title": "3. Dados",
    "section": "\n5.3 ODS",
    "text": "5.3 ODS\n\ndf_ods &lt;- import(\"df_ods.ods\")\ndf_ods\n\n   RAD REP AF_M2       AF      MST\n1   50   1  5.02 5016.429 12.30785\n2   50   2  3.65 3648.359 10.73315\n3   50   3  3.93 3925.333 10.86140\n4   50   4  4.71 4705.269 10.97850\n5   70   1  6.12 6118.425 15.75180\n6   70   2  5.61 5614.233 13.30495\n7   70   3  5.11 5109.944 13.88435\n8   70   4  4.98 4975.857 13.09225\n9  100   1  5.46 5464.528 16.92240\n10 100   2  5.55 5551.951 14.93085\n11 100   3  5.72 5723.849 16.12900\n12 100   4  5.87 5869.697 15.78145"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#rdata",
    "href": "RGV410046_03_DADOS.html#rdata",
    "title": "3. Dados",
    "section": "\n5.4 Rdata",
    "text": "5.4 Rdata\n\ndf_rdata &lt;- readRDS(\"df_r.RData\")\ndf_rdata\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP\n1      H1     I     3.002   1.878\n2      H1    II     2.974   1.834\n3      H1   III     2.814   1.674\n4      H2     I     2.104   0.910\n5      H2    II     2.120   1.034\n6      H2   III     1.924   1.018\n7      H3     I     2.132   1.052\n8      H3    II     2.126   1.012\n9      H3   III     2.182   0.992"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#mesmos-dados-diferentes-formas",
    "href": "RGV410046_03_DADOS.html#mesmos-dados-diferentes-formas",
    "title": "3. Dados",
    "section": "\n10.1 Mesmos dados, diferentes formas",
    "text": "10.1 Mesmos dados, diferentes formas\nNesta seção você aprenderá organizar dados no R no formato tidy. Colocar seus dados nesse formato requer algum trabalho inicial, mas esse trabalho compensa a longo prazo. Aqui, um foco especial será dado nas funções do pacote tidyr e do pacote metan. Se você quiser saber mais sobre a teoria por tras dos dados tidy, poderá apreciar o artigo Tidy Data.\nVocê pode representar os mesmos dados várias maneiras. O exemplo abaixo mostra os mesmos dados organizados de quatro maneiras diferentes. Cada conjunto de dados mostra os mesmos valores de duas variáveis (ALT_ESP, ALT_PLANT) mensuradas em três híbridos (HIBRIDO), considerando três repetições (BLOCOS).\n\ndf &lt;- import_list(\"examples_data.xlsx\")\ndf$df1\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP\n1      H1     I     3.002   1.878\n2      H1    II     2.974   1.834\n3      H1   III     2.814   1.674\n4      H2     I     2.104   0.910\n5      H2    II     2.120   1.034\n6      H2   III     1.924   1.018\n7      H3     I     2.132   1.052\n8      H3    II     2.126   1.012\n9      H3   III     2.182   0.992\n\ndf$df2\n\n   HIBRIDO BLOCO  VARIAVEL VALOR\n1       H1     I ALT_PLANT 3.002\n2       H1     I   ALT_ESP 1.878\n3       H1    II ALT_PLANT 2.974\n4       H1    II   ALT_ESP 1.834\n5       H1   III ALT_PLANT 2.814\n6       H1   III   ALT_ESP 1.674\n7       H2     I ALT_PLANT 2.104\n8       H2     I   ALT_ESP 0.910\n9       H2    II ALT_PLANT 2.120\n10      H2    II   ALT_ESP 1.034\n11      H2   III ALT_PLANT 1.924\n12      H2   III   ALT_ESP 1.018\n13      H3     I ALT_PLANT 2.132\n14      H3     I   ALT_ESP 1.052\n15      H3    II ALT_PLANT 2.126\n16      H3    II   ALT_ESP 1.012\n17      H3   III ALT_PLANT 2.182\n18      H3   III   ALT_ESP 0.992\n\ndf$df3\n\n  HIBRIDO ALT_ESP_I ALT_ESP_II ALT_ESP_III ALT_PLANT_I ALT_PLANT_II\n1      H1     1.878      1.834       1.674       3.002        2.974\n2      H2     0.910      1.034       1.018       2.104        2.120\n3      H3     1.052      1.012       0.992       2.132        2.126\n  ALT_PLANT_III\n1         2.814\n2         1.924\n3         2.182\n\ndf$df4\n\n  HIBRIDO      name     I    II   III\n1      H1 ALT_PLANT 3.002 2.974 2.814\n2      H1   ALT_ESP 1.878 1.834 1.674\n3      H2 ALT_PLANT 2.104 2.120 1.924\n4      H2   ALT_ESP 0.910 1.034 1.018\n5      H3 ALT_PLANT 2.132 2.126 2.182\n6      H3   ALT_ESP 1.052 1.012 0.992\n\n\nEssas são todas representações dos mesmos dados, mas são completamente diferentes do ponto de vista de uso.\n\n\n\n\n\n\nO que não fazer\n\n\n\nVamos assumir que queiramos computar a média da variável ALT_PLANT. Observe os quatro exemplos abaixo e veja qual está correto.\n\nmean(df$df1$ALT_PLANT)\n\n[1] 2.375333\n\nmean(df$df2$value)\n\nWarning in mean.default(df$df2$value): argumento não é numérico nem lógico:\nretornando NA\n\n\n[1] NA\n\nmean(df$df3$ALT_PLANT_I)\n\n[1] 2.412667\n\nmean(df$df4$I)\n\n[1] 1.846333\n\n\n\n\nUm conjunto de dados tidy é um conjunto de dados onde as três regras à seguir são respeitadas:\n\nCada variável deve ter sua própria coluna.\nCada observação deve ter sua própria linha.\nCada valor deve ter sua própria célula.\n\nA Figura à seguir mostra as regras visualmente.\n\n\nAdaptado de https://r4ds.had.co.nz/tidy-data.html#tidy-data-1\n\nApós vermos estas regras, percebemos que dos quatro conjuntos apresentados anteriormente, apenas df é tidy. Ao usarmos conjuntos de dados tidy vamos poder aproveitar uma das belezas do R: a possibilidade de aplicar funções à vetores, que neste caso nada mais são do que os valores presentes em cada coluna."
  },
  {
    "objectID": "RGV410046_03_DADOS.html#padão-padrão-padrão",
    "href": "RGV410046_03_DADOS.html#padão-padrão-padrão",
    "title": "3. Dados",
    "section": "\n10.2 Padão, padrão, padrão!",
    "text": "10.2 Padão, padrão, padrão!\n\n10.2.1 Formatar strings\nUm dos maiores equívocos cometidos ao trabalhar com conjuntos de dados e que pode impactar significativamente análises posteriores é a falta de padrão de nomenclatura, tanto em variáveis como string de caracteres. Por exemplo, suponha que tenhamos uma string de caracteres str = c(\"Env1\", \"env 1\", \"env.1\"), para representar três observações do ambiente “env 1”. Por definição, str deve representar um nível único, mas na verdade tem três níveis.\n\nstr &lt;- c(\"Env1\", \"env 1\", \"env.1\")\nstr |&gt; factor() |&gt; levels()\n\n[1] \"env 1\" \"env.1\" \"Env1\" \n\n\nA função tidy_strings() do pacote metan pode ser usada para organizar strings de caracteres colocando todas as palavras em maiúsculas, substituindo qualquer espaço, tabulação, caracteres de pontuação por _ e colocando _ entre maiúsculas e minúsculas.\n\n(tidy_str &lt;- tidy_strings(str))\n\n[1] \"ENV_1\" \"ENV_1\" \"ENV_1\"\n\ntidy_str |&gt; factor() |&gt; levels()\n\n[1] \"ENV_1\"\n\n\nExcelente! Agora temos o nível único que deveríamos ter antes.\n\n10.2.2 Formatar nomes de colunas\nO mesmo princípio visto anteriormente se aplica aos nomes das colunas. Como exemplo motivador, vamos utilziar o conjunto de dados messy.\n\nmessy &lt;- df$messy\nnames(messy)\n\n[1] \"env\" \"Gen\" \"b 1\" \"B2\"  \"b.3\"\n\n\nObserve que o nome das colunas do conjunto de dados messy não segue nenhum padrão. São observados letras minúsculas e maiúsculas, espaços e pontuações. Note o que a presença de espaços resulta na seleção de variáveis.\n\nmessy$env\nmessy$b 1\n\n# espaços requerem código adicional\nmessy$`b 1`\n\nError: &lt;text&gt;:2:9: unexpected numeric constant\n1: messy$env\n2: messy$b 1\n           ^\n\n\nPara formatar os nomes de colunas, podemos utilizar a função tidy_colnames() do pacote metan.\n\nmessy &lt;- tidy_colnames(messy)\nnames(messy)\n\n[1] \"ENV\" \"GEN\" \"B_1\" \"B_2\" \"B_3\""
  },
  {
    "objectID": "RGV410046_03_DADOS.html#inspeção",
    "href": "RGV410046_03_DADOS.html#inspeção",
    "title": "3. Dados",
    "section": "\n11.1 Inspeção",
    "text": "11.1 Inspeção\n\nmaize &lt;- df$maize\nplot_intro(maize)\n\n\n\nplot_histogram(maize)\n\n\n\nplot_missing(maize)\n\n\n\n# pacote metan\ninspect(maize, plot = TRUE)\n\n# A tibble: 10 × 10\n   Variable   Class     Missing Levels Valid_n   Min Median    Max Outlier Text \n   &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;\n 1 AMB        character No      0          780  NA    NA     NA         NA Line…\n 2 HIB        character No      0          780  NA    NA     NA         NA Line…\n 3 REP        character No      0          780  NA    NA     NA         NA Line…\n 4 APLA_PLANT numeric   Yes     -          772   0     2.52   3.3        7 &lt;NA&gt; \n 5 AIES_PLANT numeric   No      -          780   0.5   1.38   2.39       1 &lt;NA&gt; \n 6 CESP       numeric   Yes     -          776   0.8  15.4   20.4       16 &lt;NA&gt; \n 7 DIES       numeric   Yes     -          779  36.4  50.0   59.7        1 &lt;NA&gt; \n 8 MGRA       numeric   No      -          780  58.5 174.   291.         0 &lt;NA&gt; \n 9 MMG        numeric   No      -          780 123.  344.   546.         6 &lt;NA&gt; \n10 NGRA       numeric   Yes     -          779 147   517    903         10 &lt;NA&gt; \n\n\nWarning: Considering the levels of factors, .data should have 1 rows, but it\nhas 780. Use 'as_factor()' for coercing a variable to a factor.\n\n\nWarning: Expected three or more factor variables. The data has only 0.\n\n\nWarning: Missing values in variable(s) APLA_PLANT, CESP, DIES, NGRA.\n\n\nWarning: Possible text fragments in variable(s) AMB, HIB, REP.\n\n\nWarning: Possible outliers in variable(s) APLA_PLANT, AIES_PLANT, CESP, DIES,\nMMG, NGRA. Use 'find_outliers()' for more details.\n\n\nWarning: Zero values observed in variable(s) APLA_PLANT."
  },
  {
    "objectID": "RGV410046_03_DADOS.html#preencher-valores",
    "href": "RGV410046_03_DADOS.html#preencher-valores",
    "title": "3. Dados",
    "section": "\n11.2 Preencher valores",
    "text": "11.2 Preencher valores\nObserve o seguinte conjunto de dados\n\nNa hora da coleta de dados é muito comum observar células mescladas em conjuntos de dados. Observe o que acontece quando estes dados são importados para o software R.\n\n(mesclado &lt;- df$fill)\n\n   AMB HIBRIDO BLOCO ALT_PLANT\n1   A1      H1     I     3.002\n2   A1      H1    II     2.974\n3   A1      H1   III     2.814\n4   A1      H2     I     2.104\n5   A1      H2    II     2.120\n6   A1      H2   III     1.924\n7   A2      H1     I     3.002\n8   A2      H1    II     2.974\n9   A2      H1   III     2.814\n10  A2      H2     I     2.104\n11  A2      H2    II     2.120\n12  A2      H2   III     1.924\n\n\nA função fill() do pacote tidyr pode ser utilizada para preencher valores faltantes. Ela preenche os valores ausentes nas colunas selecionadas. Isso é útil no formato de saída comum em que os valores não são repetidos e são registrados apenas quando são alterados. Par\n\n(preenchido &lt;- fill(mesclado, AMB, HIBRIDO))\n\n   AMB HIBRIDO BLOCO ALT_PLANT\n1   A1      H1     I     3.002\n2   A1      H1    II     2.974\n3   A1      H1   III     2.814\n4   A1      H2     I     2.104\n5   A1      H2    II     2.120\n6   A1      H2   III     1.924\n7   A2      H1     I     3.002\n8   A2      H1    II     2.974\n9   A2      H1   III     2.814\n10  A2      H2     I     2.104\n11  A2      H2    II     2.120\n12  A2      H2   III     1.924\n\n\n\n\n\nFree website hit counter"
  },
  {
    "objectID": "RGV410046_03_DADOS.html#footnotes",
    "href": "RGV410046_03_DADOS.html#footnotes",
    "title": "3. Dados",
    "section": "Footnotes",
    "text": "Footnotes\n\nWickham, Hadley. 2014. “Tidy Data”. Journal of Statistical Software 59: 1–23.↩︎"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html",
    "href": "RGV410046_05_MANIPULACAO.html",
    "title": "5. Manipulação de Dados",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#longer",
    "href": "RGV410046_05_MANIPULACAO.html#longer",
    "title": "5. Manipulação de Dados",
    "section": "\n3.1 Longer",
    "text": "3.1 Longer\n\n(df_wide &lt;- import(\"examples_data.xlsx\", sheet = \"feijao\"))\n\n  UE BLOCO ADUBACAO   P1   P2   P3   P4   P5\n1  1     1       AO 16.0 17.0 19.0 15.0 17.0\n2  2     1       AQ 21.5 17.0 13.5 14.0 15.0\n3  3     1       SA 13.0 16.5 11.5 14.5 12.5\n4  4     2       AQ 15.0 14.0 13.0 16.0 16.0\n5  5     2       AO 14.0 17.0 18.0 16.0 14.0\n6  6     2       SA 15.0 14.0 16.0 16.0 13.0\n7  7     3       AO 17.0 17.0 11.0 16.0 15.0\n8  8     3       SA 17.0 16.0 14.0 17.0 12.0\n9  9     3       AQ 16.0 17.0 14.0 16.0 12.0\n\n\nPara organizar um conjunto de dados como esse, precisamos dinamizar as colunas problemáticas em duas novas colunas (variável e valor) utilizando a função pivot_longer().\n\n\nExemplo da função pivot_longer(). Fonte: https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\n\nPara realizar essa operação, precisamos de três parâmetros (além do conjunto de dados)\n\n\ncols: o conjunto de colunas cujos nomes são valores, não variáveis. Neste exemplo, essas são as colunas P1, P2, P3, P4 e P5.\n\nnames_to: O nome da variável para a qual mover os nomes das colunas. Aqui será \"PLANTA\".\n\nvalues_to: O nome da variável para a qual mover os valores da coluna. Aqui será \"ALTURA\".\n\n\nlong &lt;- \n  pivot_longer(df_wide,\n               cols = P1:P5,\n               names_to = \"PLANTA\",\n               values_to = \"AP\")\nlong\n\n# A tibble: 45 × 5\n      UE BLOCO ADUBACAO PLANTA    AP\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;dbl&gt;\n 1     1     1 AO       P1      16  \n 2     1     1 AO       P2      17  \n 3     1     1 AO       P3      19  \n 4     1     1 AO       P4      15  \n 5     1     1 AO       P5      17  \n 6     2     1 AQ       P1      21.5\n 7     2     1 AQ       P2      17  \n 8     2     1 AQ       P3      13.5\n 9     2     1 AQ       P4      14  \n10     2     1 AQ       P5      15  \n# ℹ 35 more rows\n\n\n\n\n\n\n\n\ntidyselect style notation\n\n\n\nA seleção de variáveis no universo tidy é prioritariamente suportada pelo pacote tidyselect. Isso significa que a seleção de variáveis pode ser realizada com base em seus nomes, posições, ou propriedades.\n\n# seleciona variáveis que contém uma determinada string\npivot_longer(df_wide,\n             cols = starts_with(\"P\"),\n             names_to = \"PLANTA\",\n             values_to = \"ALTURA\") |&gt; \n  print(n = 3)\n\n# A tibble: 45 × 5\n     UE BLOCO ADUBACAO PLANTA ALTURA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;\n1     1     1 AO       P1         16\n2     1     1 AO       P2         17\n3     1     1 AO       P3         19\n# ℹ 42 more rows\n\n# seleciona variáveis por sua posição\npivot_longer(df_wide,\n             cols = 4:8,\n             names_to = \"PLANTA\",\n             values_to = \"ALTURA\") |&gt; \n  print(n = 3)\n\n# A tibble: 45 × 5\n     UE BLOCO ADUBACAO PLANTA ALTURA\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;\n1     1     1 AO       P1         16\n2     1     1 AO       P2         17\n3     1     1 AO       P3         19\n# ℹ 42 more rows\n\n\n\n\nApós a modificação, as colunas são descartadas e obtemos as colunas de planta e altura. Assim, vemos que pivot_longer() torna os conjuntos de dados mais longos aumentando o número de linhas e diminuindo o número de colunas."
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#wider",
    "href": "RGV410046_05_MANIPULACAO.html#wider",
    "title": "5. Manipulação de Dados",
    "section": "\n3.2 Wider",
    "text": "3.2 Wider\nUma outra forma comum de dados que não seguem o formato tidy é quando observações estão espalhadas por várias linhas. Observe os dados abaixo.\n\n(dflong &lt;- import(\"examples_data.xlsx\", sheet = \"df2\"))\n\n   HIBRIDO BLOCO  VARIAVEL VALOR\n1       H1     I ALT_PLANT 3.002\n2       H1     I   ALT_ESP 1.878\n3       H1    II ALT_PLANT 2.974\n4       H1    II   ALT_ESP 1.834\n5       H1   III ALT_PLANT 2.814\n6       H1   III   ALT_ESP 1.674\n7       H2     I ALT_PLANT 2.104\n8       H2     I   ALT_ESP 0.910\n9       H2    II ALT_PLANT 2.120\n10      H2    II   ALT_ESP 1.034\n11      H2   III ALT_PLANT 1.924\n12      H2   III   ALT_ESP 1.018\n13      H3     I ALT_PLANT 2.132\n14      H3     I   ALT_ESP 1.052\n15      H3    II ALT_PLANT 2.126\n16      H3    II   ALT_ESP 1.012\n17      H3   III ALT_PLANT 2.182\n18      H3   III   ALT_ESP 0.992\n\n\nNeste caso, duas variáveis (ALT_PLANT e ALT_ESP) estão espalhadas pelas linhas. Para lidar com esse problema, utilizamos a função pivot_wider() que é o oposto de pivot_longer().\n\n\nExemplo da função pivot_wider(). Fonte: https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\n\nPara arrumarmos os dados em dflong utilizamos pivot_wider() de maneira similar à pivot_longer(). Desta vez, no entanto, precisamos apenas de dois parâmetros:\n\n\nnames_from: A coluna da qual obter nomes de variáveis. Aqui, é \"VARIAVEL\".\n\nvalues_from: A coluna da qual obter valores. Aqui é \"VALOR\".\n\n\nwider &lt;- \n   dflong |&gt; \n     pivot_wider(names_from = VARIAVEL,\n                 values_from = VALOR)\nwider\n\n# A tibble: 9 × 4\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP\n  &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 H1      I          3.00   1.88 \n2 H1      II         2.97   1.83 \n3 H1      III        2.81   1.67 \n4 H2      I          2.10   0.91 \n5 H2      II         2.12   1.03 \n6 H2      III        1.92   1.02 \n7 H3      I          2.13   1.05 \n8 H3      II         2.13   1.01 \n9 H3      III        2.18   0.992\n\n\n\n\n\n\n\n\nMúltiplos nomes e/ou valores\n\n\n\nEm alguns casos será necessário realizar a o mesmo processo anterior, mas utilizando múltiplas variáveis em names_from e/ou values_from. Aqui, também são mostrados alguns argumentos adicionais que permitem um bom nível de controle sobre como as variáveis são combinadas.\n\nwider2 &lt;- \n  dflong |&gt; \n    pivot_wider(names_from = c(VARIAVEL, BLOCO),\n                values_from = VALOR,\n                names_sep = \".\")\nwider2\n\n# A tibble: 3 × 7\n  HIBRIDO ALT_PLANT.I ALT_ESP.I ALT_PLANT.II ALT_ESP.II ALT_PLANT.III\n  &lt;chr&gt;         &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;\n1 H1             3.00      1.88         2.97       1.83          2.81\n2 H2             2.10      0.91         2.12       1.03          1.92\n3 H3             2.13      1.05         2.13       1.01          2.18\n# ℹ 1 more variable: ALT_ESP.III &lt;dbl&gt;"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#r-base",
    "href": "RGV410046_05_MANIPULACAO.html#r-base",
    "title": "5. Manipulação de Dados",
    "section": "\n6.1 R base",
    "text": "6.1 R base\n\nlong1 &lt;- long\nnames(long1)[c(1, 2)] &lt;- c(\"PARCELA\", \"REP\")\nnames(long1)\n\n[1] \"PARCELA\"  \"REP\"      \"ADUBACAO\" \"PLANTA\"   \"AP\""
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#dplyr-rename",
    "href": "RGV410046_05_MANIPULACAO.html#dplyr-rename",
    "title": "5. Manipulação de Dados",
    "section": "\n6.2 dplyr rename()\n",
    "text": "6.2 dplyr rename()\n\nA função rename() do pacote dplyr altera os nomes de variáveis individuais usando a sintaxe nome_novo = nome_antigo.\n\nrename(long,\n       PARCELA = UE,\n       REP = BLOCO) |&gt; \n  names()\n\n[1] \"PARCELA\"  \"REP\"      \"ADUBACAO\" \"PLANTA\"   \"AP\""
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#dplyr-rename_with",
    "href": "RGV410046_05_MANIPULACAO.html#dplyr-rename_with",
    "title": "5. Manipulação de Dados",
    "section": "\n6.3 dplyr rename_with()\n",
    "text": "6.3 dplyr rename_with()\n\nUma outra alternativa é rename_with(), que renomeia colunas usando uma função.\n\nrename_with(long, tolower) |&gt; names()\n\n[1] \"ue\"       \"bloco\"    \"adubacao\" \"planta\"   \"ap\""
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#metan-add_prefix-e-add_suffix",
    "href": "RGV410046_05_MANIPULACAO.html#metan-add_prefix-e-add_suffix",
    "title": "5. Manipulação de Dados",
    "section": "\n6.4 metan add_prefix() e add_suffix()\n",
    "text": "6.4 metan add_prefix() e add_suffix()\n\nPrefixos e sufixos são extremamente úteis na manipulação de dados, pois permitem que select helpers possam ser utilizados na seleção de variáveis, que será visto no próximo tópico. Aqui, vamos ver como prefixos e sufixos podem ser adicionados à nomes das variáveis.\n\nlong |&gt; \n  add_prefix(UE:PLANTA, prefix = \"Fct\") |&gt; \n  names()\n\n[1] \"Fct_UE\"       \"Fct_BLOCO\"    \"Fct_ADUBACAO\" \"Fct_PLANTA\"   \"AP\"          \n\n# utilizando select helper\nlong |&gt; \n  add_suffix(starts_with(\"A\"), suffix = \"a\") |&gt; \n  select(contains(\"_a\")) |&gt; \n  names()\n\n[1] \"ADUBACAO_a\" \"AP_a\""
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#junções-com-mutação",
    "href": "RGV410046_05_MANIPULACAO.html#junções-com-mutação",
    "title": "5. Manipulação de Dados",
    "section": "\n7.1 Junções com mutação",
    "text": "7.1 Junções com mutação\n\n\nleft_join(): inclui todas as linhas em x.\n\nright_join(): inclui todas as linhas em y.\n\ninner_join(): inclui todas as linhas em x e y.\n\nfull_join(): inclui todas as linhas em x ou y.\n\nSe uma linha em x corresponder a várias linhas em y, todas as linhas em y serão retornadas uma vez para cada linha correspondente em x.\n\n\nFonte: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf\n\nVamos à um exemplo prático!\n\ndf1 &lt;- import(\"examples_data.xlsx\", sheet = \"df_left\")\ndf2 &lt;- import(\"examples_data.xlsx\", sheet = \"df_right\")\n# computar a média para cada híbrido\n# renomear as variáveis\n\n\n# todas as linhas de df1\ndf1 |&gt; left_join(df2)\n\nJoining with `by = join_by(HIBRIDO)`\n\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP AP_M     AE_M\n1      H1     I     3.002   1.878 2.93 1.795333\n2      H1    II     2.974   1.834 2.93 1.795333\n3      H1   III     2.814   1.674 2.93 1.795333\n4      H3     I     2.132   1.052   NA       NA\n5      H3    II     2.126   1.012   NA       NA\n6      H3   III     2.182   0.992   NA       NA\n\n# todas as linhas de df2\n# suprima a mensagem informando por qual coluna(s) juntar\ndf1 |&gt; right_join(df2, by = \"HIBRIDO\")\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP     AP_M      AE_M\n1      H1     I     3.002   1.878 2.930000 1.7953333\n2      H1    II     2.974   1.834 2.930000 1.7953333\n3      H1   III     2.814   1.674 2.930000 1.7953333\n4      H2  &lt;NA&gt;        NA      NA 2.049333 0.9873333\n\n# todas as linhas de df1 e df2\ndf1 |&gt; inner_join(df2)\n\nJoining with `by = join_by(HIBRIDO)`\n\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP AP_M     AE_M\n1      H1     I     3.002   1.878 2.93 1.795333\n2      H1    II     2.974   1.834 2.93 1.795333\n3      H1   III     2.814   1.674 2.93 1.795333\n\n# todas as linhas de df1 ou df2\ndf1 |&gt; full_join(df2, keep = TRUE)\n\nJoining with `by = join_by(HIBRIDO)`\n\n\n  HIBRIDO.x BLOCO ALT_PLANT ALT_ESP HIBRIDO.y     AP_M      AE_M\n1        H1     I     3.002   1.878        H1 2.930000 1.7953333\n2        H1    II     2.974   1.834        H1 2.930000 1.7953333\n3        H1   III     2.814   1.674        H1 2.930000 1.7953333\n4        H3     I     2.132   1.052      &lt;NA&gt;       NA        NA\n5        H3    II     2.126   1.012      &lt;NA&gt;       NA        NA\n6        H3   III     2.182   0.992      &lt;NA&gt;       NA        NA\n7      &lt;NA&gt;  &lt;NA&gt;        NA      NA        H2 2.049333 0.9873333"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#junções-com-filtragem",
    "href": "RGV410046_05_MANIPULACAO.html#junções-com-filtragem",
    "title": "5. Manipulação de Dados",
    "section": "\n8.1 Junções com filtragem",
    "text": "8.1 Junções com filtragem\nAs duas seguintes funções de filtragem filtram linhas de x com base na presença ou ausência de correspondências em y:\n\n\nsemi_join() retorna todas as linhas de x com uma correspondência em y.\n\nanti_join() retorna todas as linhas de x sem uma correspondência em y.\n\n\n\nFonte: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf\n\n\n# linhas de df1 que estão em df2\ndf1 |&gt; semi_join(df2)\n\nJoining with `by = join_by(HIBRIDO)`\n\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP\n1      H1     I     3.002   1.878\n2      H1    II     2.974   1.834\n3      H1   III     2.814   1.674\n\n# linhas de df1 que NÃO estão em df2\ndf1 |&gt; anti_join(df2)\n\nJoining with `by = join_by(HIBRIDO)`\n\n\n  HIBRIDO BLOCO ALT_PLANT ALT_ESP\n1      H3     I     2.132   1.052\n2      H3    II     2.126   1.012\n3      H3   III     2.182   0.992"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#operações-com-conjuntos-vetores",
    "href": "RGV410046_05_MANIPULACAO.html#operações-com-conjuntos-vetores",
    "title": "5. Manipulação de Dados",
    "section": "\n8.2 Operações com conjuntos (vetores)",
    "text": "8.2 Operações com conjuntos (vetores)\nOperações com conjuntos são importantes na análise de dados. Por exemplo, se um determinado genótipo foi selecionado nos ambientes A, B e C, então, este determinado genótipo é a interseção dos ambientes A, B e C. Tanto o R-base quanto o pacote dplyr fornecem funções para operações com conjuntos, mas funcionam com dois conjuntos de uma vez apenas.\n\n(A &lt;- letters[1:4])\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\n(B &lt;- letters[2:5])\n\n[1] \"b\" \"c\" \"d\" \"e\"\n\n(C &lt;- letters[3:7])\n\n[1] \"c\" \"d\" \"e\" \"f\" \"g\"\n\n(D &lt;- letters[1:12])\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\"\n\nset_lits &lt;- list(A = A, B = B, C = C, D = D)\n\n# intersecção de A, B (dplyr)\nintersect(A, B)\n\n[1] \"b\" \"c\" \"d\"\n\n# intersecção de A, B e C (dplyr)\nintersect(intersect(A, B), C)\n\n[1] \"c\" \"d\"\n\n\nObserve que para computar interseções/uniões/diferenças com mais de dois conjuntos precisamos chamar (ex., intersect()) várias vezes O pacote metan fornece um grupo de funções set_*() que supera esse problema\n\n# Intersecção de A e B\nset_intersect(A, B)\n\n[1] \"b\" \"c\" \"d\"\n\n# Intersecção de A, B e C\nset_intersect(A, B, C)\n\n[1] \"c\" \"d\"\n\n# União de todos os conjuntos\n# Todas as funções entendem um objeto de classe lista\n\nset_union(set_lits)\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\"\n\n# Intersecção de todos os conjuntos\nset_intersect(set_lits)\n\n[1] \"c\" \"d\"\n\n\n\n\n\n\n\n\nDiagrama de Venn\n\n\n\nUm diagrama de Venn é um estilo de diagrama amplamente utilizado que mostra a relação lógica entre conjuntos usando curvas fechadas simples desenhadas em um plano para representar conjuntos. Muitas vezes, essas curvas são círculos ou elipses. Para mostrar as relações entre os conjuntos A, B, C e D, usamos a função venn_plot() do pacote metan.\n\nvenn_plot(set_lits, show_elements = TRUE)"
  },
  {
    "objectID": "RGV410046_05_MANIPULACAO.html#operações-com-conjuntos-data-frames",
    "href": "RGV410046_05_MANIPULACAO.html#operações-com-conjuntos-data-frames",
    "title": "5. Manipulação de Dados",
    "section": "\n8.3 Operações com conjuntos (data frames)",
    "text": "8.3 Operações com conjuntos (data frames)\nNesta seção será demonstrado como é possivel utilizar operações de cojuntos como interseção e união. É esperado que as entradas x e y tenham as mesmas variáveis. Para isto, vamos criar dois novos conjuntos de dados fictícios.\n\ndfi1 &lt;- data.frame(gen = c(\"A\", \"B\", \"C\"),\n                   y = c(2, 3, 1))\ndfi2 &lt;- data.frame(gen = c(\"B\", \"C\", \"D\"),\n                   y = c(3, 1, 4))\n\nset_intersect(dfi1, dfi2)\n\n  gen y\n1   B 3\n2   C 1\n\nset_difference(dfi1, dfi2)\n\n  gen y\n1   A 2\n\nset_union(dfi1, dfi2)\n\n  gen y\n1   A 2\n2   B 3\n3   C 1\n4   D 4\n\n\n\nFree website hit counter"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html",
    "href": "RGV410046_07_RESUMO.html",
    "title": "7. Sintetização",
    "section": "",
    "text": "# meu computador (mudar de acordo)\nsetwd(\"D:/Desktop/UFSC/aulas/classes/RGV410046/data\")"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html#uma-variável-uma-estatística",
    "href": "RGV410046_07_RESUMO.html#uma-variável-uma-estatística",
    "title": "7. Sintetização",
    "section": "\n3.1 Uma variável, uma estatística",
    "text": "3.1 Uma variável, uma estatística\nDiversos verbos do pacote dplyr podem ser utilizados para resumir conjuntos de dados. Iniciaremos com a função count() para contar valores que se repetem em uma determinada variável. Por exemplo, é possível identificar qual é o valor de NGRA que mais se repete utilizando\n\nmaize |&gt; count(NGRA, sort = TRUE)\n\n# A tibble: 367 × 2\n    NGRA     n\n   &lt;dbl&gt; &lt;int&gt;\n 1   419     8\n 2   513     8\n 3   503     7\n 4   528     7\n 5   529     7\n 6   538     7\n 7   451     6\n 8   481     6\n 9   493     6\n10   530     6\n# ℹ 357 more rows\n\n\nPara identificar quais os valores distintos de NGRA foram observados a função distinct() é usada.\n\nmaize |&gt; distinct(NGRA)\n\n# A tibble: 367 × 1\n    NGRA\n   &lt;dbl&gt;\n 1    NA\n 2   427\n 3   497\n 4   523\n 5   551\n 6   529\n 7   294\n 8   528\n 9   538\n10   582\n# ℹ 357 more rows\n\n\nPara calcular a média da variável NGRA usamos a função summarise() é usada.\n\nmaize |&gt; summarise(media_ngra = mean(NGRA))\n\n# A tibble: 1 × 1\n  media_ngra\n       &lt;dbl&gt;\n1         NA\n\n# checar valores faltantes\nplot_missing(maize)\n\n\n\n# remover os NAs para cálculo da estatística\nmaize |&gt; summarise(media_ngra = mean(NGRA, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  media_ngra\n       &lt;dbl&gt;\n1       512.\n\n#usando o R base\nmean(maize$NGRA, na.rm = TRUE)\n\n[1] 511.5186"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html#uma-variável-diversas-estatísticas",
    "href": "RGV410046_07_RESUMO.html#uma-variável-diversas-estatísticas",
    "title": "7. Sintetização",
    "section": "\n3.2 Uma variável, diversas estatísticas",
    "text": "3.2 Uma variável, diversas estatísticas\nUtilizando a função summarise() é possível criar uma ou mais variáveis escalares resumindo as variáveis de um data frame existente. Como resultado, uma linha e várias colunas é retornada. O seguinte código calcula a média global e o desvio padrão amostral da variável MGRA eretorna o n utilizado na estimativa.\n\nmaize |&gt;  \n  summarise(MGRA_mean = mean(MGRA),\n            MGRA_sd = sd(MGRA),\n            n = n())\n\n# A tibble: 1 × 3\n  MGRA_mean MGRA_sd     n\n      &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;\n1      173.    47.6   780\n\n\nMuitas vezes é necessário computar uma determinada função (como a média) para cada nível de uma variável categórica. Continuamos no mesmo exemplo anterior, mas agora neste caso, o objetivo é calcular a média da MGRA para cada híbrido. Utilizando a função group_by() antes da função summarise() uma linha de resultado para cada nível do fator híbrido é retornado.\n\nmaize |&gt;\n  group_by(HIB) %&gt;%\n  summarise(MGRA_mean = mean(MGRA),\n            MGRA_max = max(MGRA),\n            MGRA_min = min(MGRA))\n\n# A tibble: 13 × 4\n   HIB   MGRA_mean MGRA_max MGRA_min\n   &lt;chr&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 H1         184.     260.     75.2\n 2 H10        164.     287.     71.5\n 3 H11        167.     260.     94.9\n 4 H12        157.     257.     66.8\n 5 H13        180.     291.     89.3\n 6 H2         187.     273.     83.7\n 7 H3         169.     263.     73.2\n 8 H4         184.     262.    108. \n 9 H5         184.     256.     72.8\n10 H6         188.     289.     65.3\n11 H7         171.     254.     62.4\n12 H8         160.     277.     59.5\n13 H9         153.     255.     58.5"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html#diversas-variáveis-uma-estatística",
    "href": "RGV410046_07_RESUMO.html#diversas-variáveis-uma-estatística",
    "title": "7. Sintetização",
    "section": "\n3.3 Diversas variáveis, uma estatística",
    "text": "3.3 Diversas variáveis, uma estatística\nAté aqui vimos como a média (global ou para cada híbrido) da MGRA pode ser calculada. Quase sempre, no entanto, quando calculamos a média (ou qualquer outra medida) em um conjunto de dados, queremos fazê-la para todas (ou algumas) variáveis numéricas dos dados. Implementar isto com dplyr é relativamente fácil. Para isto, é utilizada a função across() que aplica uma função (ou um conjunto de funções) a um conjunto de colunas. Veremos como across() pode ser utilizada para calcular a média para as variáveis numéricas do conjunto maize. No exemplo abaixo, where() aplica uma função (neste caso is.numeric()) a todas as variáveis e seleciona aquelas para as quais a função retorna TRUE. Assim, a média somente é calculada para as variáveis numéricas.\n\nmaize |&gt; \n  summarise(across(.cols = where(is.numeric),\n                   .fns =  mean,\n                   na.rm = TRUE)) \n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE)`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 1 × 7\n  APLA_PLANT AIES_PLANT  CESP  DIES  MGRA   MMG  NGRA\n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1       2.47       1.34  15.2  49.5  173.  339.  512.\n\n\nFunções próprias podem ser aplicadas dentro da função summarise() para computar uma estatística personalizada. Como exemplo, vamos criar uma função chamada se que retornará o erro padrão da média e aplicá-la a todas as variáveis que iniciam \"M\", para cada nível do fator AMB.\n\nse &lt;- function(dados){\n  sd(dados, na.rm = TRUE) / sqrt(length(na.omit(dados)))\n}\n\nmaize |&gt;\n  group_by(AMB) %&gt;%\n  summarise(across(.cols = contains(\"_PLANT\"),\n                   .fns = se,\n                   .names = \"{.col}.se\"))\n\n# A tibble: 4 × 3\n  AMB   APLA_PLANT.se AIES_PLANT.se\n  &lt;chr&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 A1           0.0156        0.0134\n2 A2           0.0339        0.0264\n3 A3           0.0246        0.0161\n4 A4           0.0178        0.0152"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html#diversas-variáveis-diversas-estatísticas",
    "href": "RGV410046_07_RESUMO.html#diversas-variáveis-diversas-estatísticas",
    "title": "7. Sintetização",
    "section": "\n3.4 Diversas variáveis, diversas estatísticas",
    "text": "3.4 Diversas variáveis, diversas estatísticas\nSe desejamos computar mais de uma estatística para variáveis específicas, então o próximo código nos ajudará. Note que para aplicar mais de uma função é necessário criar uma lista com o nome das funções. Neste caso, os sufixos _m e _sd representam a média e o desvio padrão, respectivamente. Faremos isso para cada nível da variável HIB.\n\nmaize %&gt;%\n  group_by(HIB, AMB) |&gt; \n  summarise(across(starts_with(\"M\"),\n                   .fns =  list(m = mean, sd = sd)))\n\n`summarise()` has grouped output by 'HIB'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 52 × 6\n# Groups:   HIB [13]\n   HIB   AMB   MGRA_m MGRA_sd MMG_m MMG_sd\n   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 H1    A1      203.    42.2  382.   48.1\n 2 H1    A2      188.    27.7  389.   22.2\n 3 H1    A3      157.    54.8  369.   65.2\n 4 H1    A4      187.    37.0  319.   43.6\n 5 H10   A1      192.    50.0  372.   54.0\n 6 H10   A2      160.    37.0  316.   52.8\n 7 H10   A3      121.    36.7  247.   41.6\n 8 H10   A4      183.    45.5  345.   51.3\n 9 H11   A1      188.    38.9  353.   45.7\n10 H11   A2      164.    34.3  342.   29.3\n# ℹ 42 more rows"
  },
  {
    "objectID": "RGV410046_07_RESUMO.html#quick-tips",
    "href": "RGV410046_07_RESUMO.html#quick-tips",
    "title": "7. Sintetização",
    "section": "\n3.5 Quick tips",
    "text": "3.5 Quick tips\n\nmy_quantile &lt;- function(x, probs) {\n  tibble::tibble(x = quantile(x, probs), probs = probs)\n}\nmtcars %&gt;%\n  group_by(cyl) %&gt;%\n  summarise(my_quantile(disp, c(0.25, 0.75)))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n`summarise()` has grouped output by 'cyl'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 6 × 3\n# Groups:   cyl [3]\n    cyl     x probs\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     4  78.8  0.25\n2     4 121.   0.75\n3     6 160    0.25\n4     6 196.   0.75\n5     8 302.   0.25\n6     8 390    0.75\n\nmaize %&gt;%\n   group_by(HIB) %&gt;%\n  summarise(my_quantile(MGRA, c(0.25, 0.75)))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n`summarise()` has grouped output by 'HIB'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 26 × 3\n# Groups:   HIB [13]\n   HIB       x probs\n   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 H1     162.  0.25\n 2 H1     211.  0.75\n 3 H10    131.  0.25\n 4 H10    199.  0.75\n 5 H11    144.  0.25\n 6 H11    193.  0.75\n 7 H12    121.  0.25\n 8 H12    186.  0.75\n 9 H13    146.  0.25\n10 H13    211.  0.75\n# ℹ 16 more rows\n\n\n\nFree website hit counter"
  }
]